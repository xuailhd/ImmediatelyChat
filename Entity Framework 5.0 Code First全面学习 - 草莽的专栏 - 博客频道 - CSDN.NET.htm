<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
     
    <html xmlns="http://www.w3.org/1999/xhtml">
    
<head>   
    
     
    <script type="text/javascript" src="http://c.csdnimg.cn/pubfooter/js/tracking.js" charset="utf-8"></script>  

    <script type="text/javascript">
        var protocol = window.location.protocol;
        document.write('<script type="text/javascript" src="' + protocol + '//csdnimg.cn/pubfooter/js/repoAddr2.js?v=' + Math.random() + '"></' + 'script>');
    </script>

  
 <meta http-equiv="Cache-Control" content="no-siteapp" /><link rel="alternate" media="handheld" href="#" />

    <title>Entity Framework 5.0 Code First全面学习 - 草莽的专栏
        - 博客频道 - CSDN.NET</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="description" content="出于最近对im研究的兴趣，看到smack里有个30s发送一个空消息的线程，了解了下关于心跳包，keepalive的知识。 TCP的socket本身就是长连接的，那么为什么还要心跳包呢？搜索到的资料解释如下：一：内网机器如果不主动向外发起连接，外网机没法直连内网的，这也是内网机安全的原因之一吧，又因为路由器会把这个关系记录下来，但是过一段时间这个记录可能会丢失 ，所有每一个客户端每隔" />
    <script src="http://static.blog.csdn.net/scripts/jquery.js" type="text/javascript"></script>
    <script type="text/javascript" src="http://static.blog.csdn.net/scripts/ad.js?v=1.1"></script>
        <!--new top-->
               <link rel="stylesheet" href="http://c.csdnimg.cn/public/common/toolbar/css/index.css">        <!--new top-->

    <link rel="Stylesheet" type="text/css" href="http://static.blog.csdn.net/skin/dark1/css/style.css?v=1.1" />
    <link id="RSSLink" title="RSS" type="application/rss+xml" rel="alternate" href="/gentle_wolf/rss/list" />
    <link rel="shortcut icon" href="http://c.csdnimg.cn/public/favicon.ico" />
    <link type="text/css" rel="stylesheet" href="http://static.blog.csdn.net/scripts/SyntaxHighlighter/styles/blue_green.css" />
 


</head>
<body>
    
   
      <!--new top-->
    <script id="toolbar-tpl-scriptId" fixed="true" prod="blog" skin="black" src="http://c.csdnimg.cn/public/common/toolbar/js/html.js" type="text/javascript"></script>
     <!--new top-->
    <div id="container">
        <div id="header">
    <div class="header">
        <div id="blog_title">
            <h2>
                <a href="http://blog.csdn.net/gentle_wolf">草莽的专栏</a></h2>
            <h3>太上，不知有之；其次，亲而誉之；其次，畏之；其次辱之。信不足焉，有不信焉。悠兮，其言贵。功成事遂，百姓皆谓：我自然</h3>
            <div class="clear">
            </div>
        </div>
        <div class="clear">
        </div>
    </div>
</div>
<div id="navigator">
    <div class="navigator_bg">
    </div>
    <div class="navigator">
        <ul>
            
                <li id="btnContents"><a href="http://blog.csdn.net/gentle_wolf?viewmode=contents"><span onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_mulu'])">
                    <img src="http://static.blog.csdn.net/images/ico_list.gif">目录视图</span></a></li>
                <li id="btnView"><a href="http://blog.csdn.net/gentle_wolf?viewmode=list"><span onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_zhaiyao'])">
                    <img src="http://static.blog.csdn.net/images/ico_summary.gif">摘要视图</span></a></li>
                <li id="btnRss"><a href="http://blog.csdn.net/gentle_wolf/rss/list"><span onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_RSS'])">
                    <img src="http://static.blog.csdn.net/images/ico_rss.gif">订阅</span></a></li>                

            </ul>
    </div>
</div>
<script type="text/javascript">
    var username = "gentle_wolf";
    var _blogger = username;
    var blog_address = "http://blog.csdn.net/gentle_wolf";
    var static_host = "http://static.blog.csdn.net";
    var currentUserName = "";  
</script>

        <div id="body">
            <div id="main">
                <div class="main">
                        <div class="ad_class">
<div class="notice tracking-ad" data-mod='popu_3' > 

<a href="http://huiyi.csdn.net/activity/product/goods_list?project_id=2741">
<font color=red>2016软考项目经理实战班
</font></a>
&nbsp;&nbsp;&nbsp;

<a href="http://edu.csdn.net/yearPromotion">
<font color=blue>学院周年礼-顶尖课程钜惠呈现
</font></a>
&nbsp;&nbsp;&nbsp;
<a href="http://huiyi.csdn.net/activity/product/goods_list?project_id=2792">
<font color=red>Hadoop英雄会—暨Hadoop 10周年生日大趴</font>
&nbsp;&nbsp;&nbsp;
<a href="http://blog.csdn.net/dba_huangzj/article/details/50469185">
<font color=blue>【博客专家】有奖试读—Windows PowerShell实战指南
</font></a>

</div>                        </div>
                        

<!--AdForward Begin:-->
<script type="text/javascript" ads-src="http://csdnim.qtmojo.com/main/s?user=csdn|blog|fumeiti&db=csdnim&border=0&local=yes&js=ie" src="http://creatim.qtmojo.cn/td/AllyesDeliver.min.js" charset="gbk"></script>
<!--AdForward End-->

  
<link href="http://static.blog.csdn.net/css/comment1.css" type="text/css" rel="stylesheet" />
<link href="http://static.blog.csdn.net/css/style1.css" type="text/css" rel="stylesheet" />
<script language='JavaScript' type='text/javascript' src='http://download.csdn.net/js/jquery.cookie.js'></script>
<script type="text/javascript" src="http://c.csdnimg.cn/rabbit/search-service/main.js"></script>
<link rel="stylesheet" href="http://static.blog.csdn.net/public/res-min/markdown_views.css?v=1.0" />
<link rel="stylesheet" href="http://static.blog.csdn.net/css/category.css?v=1.0" />
<script type="text/javascript" src="http://static.blog.csdn.net/public/res/bower-libs/MathJax/MathJax.js?config=TeX-AMS_HTML"></script>

  <script type="text/ecmascript">
      window.quickReplyflag = true;
           
            var isBole = false;
            
          
    </script>
<div id="article_details" class="details">
    <div class="article_title">   
         <span class="ico ico_type_Original"></span>


    <h1>
        <span class="link_title"><a href="/gentle_wolf/article/details/14004345">
        Entity Framework 5.0 Code First全面学习            
        </a></span>
    </h1>
</div>

   

        <div class="article_manage clearfix">
        <div class="article_l">
            <span class="link_categories">
            标签：
              <a href='http://www.csdn.net/tag/entity%20framework' target=_blank onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_tag']);">entity framework</a><a href='http://www.csdn.net/tag/.net' target=_blank onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_tag']);">.net</a>
            </span>
        </div>
        <div class="article_r">
            <span class="link_postdate">2013-11-01 17:20</span>
            <span class="link_view" title="阅读次数">44195人阅读</span>
            <span class="link_comments" title="评论次数"> <a href="#comments" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_pinglun'])">评论</a>(15)</span>
            <span class="link_collect tracking-ad" data-mod="popu_171"> <a href="javascript:void(0);" onclick="javascript:collectArticle('Entity Framework 5.0 Code First全面学习','14004345');return false;" title="收藏">收藏</a></span>
             <span class="link_report"> <a href="#report" onclick="javascript:report(14004345,2);return false;" title="举报">举报</a></span>

        </div>
    </div>
      <div class="category clearfix">
        <div class="category_l">
           <img src="http://static.blog.csdn.net/images/category_icon.jpg">
            <span>分类：</span>
        </div>
        <div class="category_r">
                    <label  onclick="GetCategoryArticles('1358589','gentle_wolf','top','14004345');">
                        <span onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_fenlei']);">EF<em>（1）</em></span>
                      <img class="arrow-down" src="http://static.blog.csdn.net/images/arrow_triangle _down.jpg" style="display:inline;">
                      <img class="arrow-up" src="http://static.blog.csdn.net/images/arrow_triangle_up.jpg" style="display:none;">
                        <div class="subItem">
                            <div class="subItem_t"><a  href="http://blog.csdn.net/gentle_wolf/article/category/1358589"  target="_blank">作者同类文章</a><i class="J_close">X</i></div>
                            <ul class="subItem_l" id="top_1358589">                            
                            </ul>
                        </div>
                    </label>                    
        </div>
    </div>
    <script   type="text/javascript" src="http://static.blog.csdn.net/scripts/category.js"></script>  
        <div   class="bog_copyright">         
            <p  class="copyright_p" >版权声明：本文为博主原创文章，未经博主允许不得转载。</p>
        </div>

  

  
  
     

<div id="article_content" class="article_content">

<p>不贴图片了，太累。</p>
<p>Code First 约定</p>
<p>借助 CodeFirst，可通过使用 C# 或Visual Basic .NET 类来描述模型。模型的基本形状可通过约定来检测。约定是规则集，用于在使用 Code First 时基于类定义自动配置概念模型。约定是在 System.Data.Entity.ModelConfiguration.Conventions 命名空间中定义的。</p>
<p>可通过使用数据注释或Fluent API 进一步配置模型。优先级是通过 Fluent API 进行配置，然后是通过数据注释，再次是通过约定。</p>
<p>API 文档中提供了 Code First 约定的详细列表。本主题概述 Code First 使用的约定。</p>
<h2>类型发现</h2>
<p>当使用 CodeFirst 开发时，通常是从编写用来定义概念（域）模型的 .NET类开始。除了定义类之外，还需要让 DbContext 知道模型中要包含哪些类。为此，需要定义一个上下文类，此类派生自 DbContext 并公开需要成为模型一部分的类型的 DbSet 属性。Code First 将包含这些类型，还将包含任何引用类型，即使这些引用类型是在不同的程序集中定义的也是如此。</p>
<p>如果类型存在于继承层次结构中，则为基类定义 DbSet 属性就足够了，如果派生类型位于与基类相同的程序集中，则自动包含这些派生类型。</p>
<p>在下面的示例中，仅对SchoolEntities 类定义一个DbSet 属性 (Departments)。CodeFirst 使用此属性来发现并包含任何引用类型。</p>
<p><span style="color:blue">public</span><span style="color:blue">class</span> <span style="color:#2B91AF">
SchoolEntities</span>: <span style="color:#2B91AF">DbContext</span></p>
<p>{</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:#2B91AF">DbSet</span>&lt;<span style="color:#2B91AF">Department</span>&gt;Departments {
<span style="color:blue">get</span>; <span style="color:blue">set</span>;}</p>
<p>}</p>
<p>&nbsp;</p>
<p><span style="color:blue">public</span><span style="color:blue">class</span> <span style="color:#2B91AF">
Department</span></p>
<p>{</p>
<p>&nbsp; <span style="color:green">// Primary key</span></p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">int</span> DepartmentID {
<span style="color:blue">get</span>;<span style="color:blue">set</span>; }</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">string</span> Name {
<span style="color:blue">get</span>; <span style="color:blue">set</span>; }</p>
<p>&nbsp;</p>
<p>&nbsp; <span style="color:green">// Navigationproperty</span></p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">virtual</span>
<span style="color:#2B91AF">ICollection</span>&lt;<span style="color:#2B91AF">Course</span>&gt; Courses {
<span style="color:blue">get</span>;<span style="color:blue">set</span>; }</p>
<p>}</p>
<p>&nbsp;</p>
<p><span style="color:blue">public</span><span style="color:blue">class</span> <span style="color:#2B91AF">
Course</span></p>
<p>{</p>
<p>&nbsp; <span style="color:green">// Primary key</span></p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">int</span> CourseID {
<span style="color:blue">get</span>; <span style="color:blue">set</span>; }</p>
<p>&nbsp;</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">string</span> Title {
<span style="color:blue">get</span>; <span style="color:blue">set</span>; }</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">int</span> Credits {
<span style="color:blue">get</span>; <span style="color:blue">set</span>; }</p>
<p>&nbsp;</p>
<p>&nbsp; <span style="color:green">// Foreign key</span></p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">int</span> DepartmentID {
<span style="color:blue">get</span>;<span style="color:blue">set</span>; }</p>
<p>&nbsp;</p>
<p>&nbsp; <span style="color:green">// Navigationproperties</span></p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">virtual</span>
<span style="color:#2B91AF">Department</span>Department { <span style="color:blue">
get</span>; <span style="color:blue">set</span>;}</p>
<p>}</p>
<p>&nbsp;</p>
<p><span style="color:blue">public</span><span style="color:blue">partial</span> <span style="color:blue">
class</span> <span style="color:#2B91AF">OnlineCourse</span> : <span style="color:#2B91AF">
Course</span></p>
<p>{</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">string</span> URL {
<span style="color:blue">get</span>; <span style="color:blue">set</span>; }</p>
<p>}</p>
<p>&nbsp;</p>
<p><span style="color:blue">public</span><span style="color:blue">partial</span> <span style="color:blue">
class</span> <span style="color:#2B91AF">OnsiteCourse</span> : <span style="color:#2B91AF">
Course</span></p>
<p>{</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">string</span> Location {
<span style="color:blue">get</span>;<span style="color:blue">set</span>; }</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">string</span> Days {
<span style="color:blue">get</span>; <span style="color:blue">set</span>; }</p>
<p>&nbsp; <span style="color:blue">public</span>System.<span style="color:#2B91AF">DateTime</span> Time {
<span style="color:blue">get</span>; <span style="color:blue">set</span>; }</p>
<p>}</p>
<p>如果要从模型排除类型，请使用 NotMapped 特性或DbModelBuilder.Ignore</p>
<h2>主键约定</h2>
<p>如果类的属性名为“ID”（不区分大小写）或类名的后面跟有“ID”，则 Code First 会推断该属性是主键。如果主键属性的类型为数&#20540;或 GUID，则将其配置为标识列。</p>
<p><span style="color:blue">public</span><span style="color:blue">class</span> <span style="color:#2B91AF">
Department</span></p>
<p>{</p>
<p>&nbsp; <span style="color:green">// Primary key</span></p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">int</span> DepartmentID {
<span style="color:blue">get</span>;<span style="color:blue">set</span>; }</p>
<p>}</p>
<p>&nbsp;</p>
<h2>关系约定</h2>
<p>实体框架中的导航属性提供了一种在两个实体类型之间导航关系的方法。针对对象参与到其中的每个关系，各对象均可以具有导航属性。使用导航属性，可以在两个方向上导航和管理关系，返回引用对象（如果多重性为一或者零或一）或集合（如果多重性为多）。Code First 根据针对类型定义的导航属性来推断关系。</p>
<p>除导航属性外，建议还要包括表示依赖对象的类型的外键属性。任何数据类型与主体主键属性相同、遵循以下一种&#26684;式的属性都表示关系的外键：“&lt;导航属性名称&gt;&lt;主体主键属性&gt;”、“&lt;主体类名&gt;&lt;主键属性名称&gt;”或“&lt;主体主键属性名称&gt;”。如果找到多个匹配项，则优先级符合上面列出的顺序。外键检测不区分大小写。在检测外键属性时，Code First 基于外键的可空性推断关系的多重性。如果属性可以为 Null，则将关系注册为可选关系；否则，将关系注册为必需关系。</p>
<p>如果依赖实体上的外键不能为 Null，则 CodeFirst 对关系设置级联删除。如果依赖实体上的外键可以为 Null，则Code First 不对关系设置级联删除，并且在删除主体时，会将该外键设置为 Null。通过使用 Fluent API，可以覆盖由约定检测的多重性和级联删除行为。</p>
<p><span style="color:blue">public</span><span style="color:blue">class</span> <span style="color:#2B91AF">
Department</span></p>
<p>{</p>
<p>&nbsp; <span style="color:green">// Primary key</span></p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">int</span> DepartmentID {
<span style="color:blue">get</span>;<span style="color:blue">set</span>; }</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">string</span> Name {
<span style="color:blue">get</span>; <span style="color:blue">set</span>; }</p>
<p>&nbsp;</p>
<p>&nbsp; <span style="color:green">// Navigationproperty</span></p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">virtual</span>
<span style="color:#2B91AF">ICollection</span>&lt;<span style="color:#2B91AF">Course</span>&gt; Courses {
<span style="color:blue">get</span>;<span style="color:blue">set</span>; }</p>
<p>}</p>
<p>&nbsp;</p>
<p><span style="color:blue">public</span><span style="color:blue">class</span> <span style="color:#2B91AF">
Course</span></p>
<p>{</p>
<p>&nbsp; <span style="color:green">// Primary key</span></p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">int</span> CourseID {
<span style="color:blue">get</span>; <span style="color:blue">set</span>; }</p>
<p>&nbsp;</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">string</span> Title {
<span style="color:blue">get</span>; <span style="color:blue">set</span>; }</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">int</span> Credits {
<span style="color:blue">get</span>; <span style="color:blue">set</span>; }</p>
<p>&nbsp;</p>
<p>&nbsp; <span style="color:green">// Foreign key</span></p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">int</span> DepartmentID {
<span style="color:blue">get</span>;<span style="color:blue">set</span>; }</p>
<p>&nbsp;</p>
<p>&nbsp; <span style="color:green">// Navigationproperties</span></p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">virtual</span>
<span style="color:#2B91AF">Department</span>Department { <span style="color:blue">
get</span>; <span style="color:blue">set</span>;}</p>
<p>}</p>
<p>&nbsp;</p>
<p>在下面的示例中，导航属性和外键用于定义 Department 类与Course 类之间的关系。</p>
<p><strong>注意</strong>：如果相同类型间有多个关系（例如，假设定义 Person 和Book 类，其中，Person 包含ReviewedBooks 和AuthoredBooks 导航属性，而Book 类包含 Author 和Reviewer 导航属性），则需要使用数据注释或 Fluent API 手动配置关系。</p>
<h2>复杂类型约定</h2>
<p>当 CodeFirst 发现无法推断主键以及未通过数据注释或 Fluent API 注册主键的类时，类型会自动注册为复杂类型。复杂类型检测还要求类型不具有引用实体类型的属性，并且未被其他类型的集合属性引用。对于以下类定义，Code First 推断Details 是复杂类型，因为它没有主键。</p>
<p><span style="color:blue">public</span><span style="color:blue">partial</span> <span style="color:blue">
class</span> <span style="color:#2B91AF">OnsiteCourse</span> : <span style="color:#2B91AF">
Course</span></p>
<p>{</p>
<p>&nbsp; <span style="color:blue">public</span>OnsiteCourse()</p>
<p>&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp; Details = <span style="color:blue">new</span><span style="color:#2B91AF">Details</span>();</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:#2B91AF">Details</span> Details {
<span style="color:blue">get</span>;<span style="color:blue">set</span>; }</p>
<p>}</p>
<p>&nbsp;</p>
<p><span style="color:blue">public</span><span style="color:blue">class</span> <span style="color:#2B91AF">
Details</span></p>
<p>{</p>
<p>&nbsp; <span style="color:blue">public</span>System.<span style="color:#2B91AF">DateTime</span> Time {
<span style="color:blue">get</span>; <span style="color:blue">set</span>; }</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">string</span> Location {
<span style="color:blue">get</span>;<span style="color:blue">set</span>; }</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">string</span> Days {
<span style="color:blue">get</span>; <span style="color:blue">set</span>; }</p>
<p>}</p>
<h2>&nbsp;</h2>
<h2>连接字符串约定</h2>
<h3>默认配置</h3>
<p>如果您还没有在应用程序中进行任何其他配置，则对 DbContext 调用无参数构造函数将会导致 DbContext 使用按约定创建的数据库连接在 Code First 模式下运行。例如：</p>
<p><span style="color:blue">namespace</span>Demo.EF</p>
<p>{</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">class</span>
<span style="color:#2B91AF">BloggingContext</span>: <span style="color:#2B91AF">DbContext</span></p>
<p>&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp; <span style="color:blue">public</span>BloggingContext()</p>
<p>&nbsp;&nbsp;&nbsp; <span style="color:green">// C# will callbase class parameterless constructor by default</span></p>
<p>&nbsp;&nbsp;&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp; }</p>
<p>}</p>
<p>在此示例中，DbContext使用派生上下文类 Demo.EF.BloggingContext 的命名空间限定名称作为数据库名称，并使用 SQL Express 或 LocalDb 为此数据库创建连接字符串。如果同时安装了这两个数据库，将使用 SQL Express。</p>
<p>默认情况下，VisualStudio 2010 包含 SQLExpress，VisualStudio 2012 包含LocalDb。安装期间，EntityFrameworkNuGet 包会检查哪个数据库服务器可用。随后 NuGet 包将设置按约定创建连接时 Code First 所使用的默认数据库服务器，以此更新配置文件。如果 SQL Express 正在运行，将使用它。如果 SQL Express 不可用，则 LocalDb 将注册为默认数据库。如果配置文件已包含默认连接工厂设置，则不会更改该文件。</p>
<h3>指定数据库名称</h3>
<p>如果您尚未在应用程序中进行任何其他配置，在通过要使用的数据库名称对 DbContext 调用字符串构造函数时，将会导致 DbContext 使用按约定创建的与该名称数据库的连接在 Code First 模式下运行。例如：</p>
<p><span style="color:blue">namespace</span>Demo.EF</p>
<p>{</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">class</span>
<span style="color:#2B91AF">BloggingContext</span>: <span style="color:#2B91AF">DbContext</span></p>
<p>&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp; <span style="color:blue">public</span> BloggingContext()</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : <span style="color:blue">base</span>(<span style="color:#A31515">&quot;BloggingDatabase&quot;</span>)</p>
<p>&nbsp;&nbsp;&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp; }</p>
<p>}</p>
<p>在此示例中，DbContext使用“BloggingDatabase”作为数据库名称，并使用 SQL Express（随Visual Studio 2010 安装）或LocalDb（随Visual Studio 2012 安装）为此数据库创建连接字符串。如果同时安装了这两个数据库，将使用 SQL Express。</p>
<h3>指定连接字符串</h3>
<p>可以选择将连接字符串放入 app.config 或web.config 文件中。例如：</p>
<p><span style="color:blue">&lt;</span><span style="color:#A31515">configuration</span><span style="color:blue">&gt;</span></p>
<p><span style="color:blue">&nbsp; &lt;</span><span style="color:#A31515">connectionStrings</span><span style="color:blue">&gt;</span></p>
<p><span style="color:blue">&nbsp;&nbsp;&nbsp; &lt;</span><span style="color:#A31515">add</span><span style="color:red">name</span><span style="color:blue">=</span>&quot;<span style="color:blue">BloggingCompactDatabase</span>&quot;</p>
<p><span style="color:blue">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:red">providerName</span><span style="color:blue">=</span>&quot;<span style="color:blue">System.Data.SqlServerCe.4.0</span>&quot;</p>
<p><span style="color:blue">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:red">connectionString</span><span style="color:blue">=</span>&quot;<span style="color:blue">Data Source=Blogging.sdf</span>&quot;<span style="color:blue">/&gt;</span></p>
<p><span style="color:blue">&nbsp; &lt;/</span><span style="color:#A31515">connectionStrings</span><span style="color:blue">&gt;</span></p>
<p><span style="color:blue">&lt;/</span><span style="color:#A31515">configuration</span><span style="color:blue">&gt;</span></p>
<p>这是一种指示 DbContext 使用数据库服务器而非 SQL Express 或LocalDb 的简单方法 — 上例指定了 SQL Server Compact Edition 数据库。</p>
<p>如果连接字符串的名称与上下文的名称（带或不带命名空间限定）相同，则使用无参数构造函数时 DbContext 会找到该连接字符串。如果连接字符串名称与上下文名称不同，则可通过将连接字符串名称传递给 DbContext 构造函数，指示 DbContext 在 CodeFirst 模式下使用此连接。例如：</p>
<p><span style="color:blue">public</span><span style="color:blue">class</span> <span style="color:#2B91AF">
BloggingContext</span>: <span style="color:#2B91AF">DbContext</span></p>
<p>{</p>
<p>&nbsp; <span style="color:blue">public</span>BloggingContext()</p>
<p>&nbsp;&nbsp;&nbsp; : <span style="color:blue">base</span>(<span style="color:#A31515">&quot;BloggingCompactDatabase&quot;</span>)</p>
<p>&nbsp; {</p>
<p>&nbsp; }</p>
<p>}</p>
<p>或者，也可以对传递给DbContext 构造函数的字符串使用 “name=&lt;连接字符串名称&gt;”&#26684;式。例如：</p>
<p><span style="color:blue">public</span><span style="color:blue">class</span> <span style="color:#2B91AF">
BloggingContext</span>: <span style="color:#2B91AF">DbContext</span></p>
<p>{</p>
<p>&nbsp; <span style="color:blue">public</span>BloggingContext()</p>
<p>&nbsp;&nbsp;&nbsp; : <span style="color:blue">base</span>(<span style="color:#A31515">&quot;name=BloggingCompactDatabase&quot;</span>)</p>
<p>&nbsp; {</p>
<p>&nbsp; }</p>
<p>}</p>
<p>使用此形式可以明确要求在配置文件中查找连接字符串。如果未找到具有给定名称的连接字符串，则将引发异常。</p>
<h2>数据库初始化策略：</h2>
<p>数据库创建是由策略来控制的，有如下四种策略：</p>
<p>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CreateDatabaseIfNotExists：这是默认的策略。如果数据库不存在，那么就创建数据库。但是如果数据库存在了，而且实体发生了变化，就会出现异常。</p>
<p>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DropCreateDatabaseIfModelChanges：此策略表明，如果模型变化了，数据库就会被重新创建，原来的数据库被删除掉了。</p>
<p>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DropCreateDatabaseAlways：此策略表示，每次运行程序都会重新创建数据库，这在开发和调试的时候非常有用。</p>
<p>4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自定制数据库策略：可以自己实现IDatabaseInitializer来创建自己的策略。或者从已有的实现了IDatabaseInitializer接口的类派生。</p>
<p>如下示例显示了如何应用数据库创建策略：</p>
<p><span style="color:blue">public</span> <span style="color:blue">class</span> <span style="color:rgb(43,145,175)">
UserManContext</span> : <span style="color:rgb(43,145,175)">DbContext</span></p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp; <span style="color:blue">public</span> UserManContext()</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : <span style="color:blue">base</span>(<span style="color:rgb(163,21,21)">&quot;USMDBConnectionString&quot;</span>)</p>
<p>&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:rgb(43,145,175)">Database</span>.SetInitializer&lt;<span style="color:rgb(43,145,175)">UserManContext</span>&gt;(<span style="color:blue">new</span>
<span style="color:rgb(43,145,175)">CreateDatabaseIfNotExists</span>&lt;<span style="color:rgb(43,145,175)">UserManContext</span>&gt;());</p>
<p>&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; </p>
<p>}</p>
<p>下面的代码创建了一个自定义策略，什么也没有做，但是我们可以在Seed方法里添加我们的种子数据。</p>
<p><span style="color:blue">public</span> <span style="color:blue">class</span> <span style="color:rgb(43,145,175)">
USMDBInitializer</span> : <span style="color:rgb(43,145,175)">DropCreateDatabaseAlways</span>&lt;<span style="color:rgb(43,145,175)">UserManContext</span>&gt;</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp; <span style="color:blue">protected</span> <span style="color:blue">override</span>
<span style="color:blue">void</span> Seed(<span style="color:rgb(43,145,175)">UserManContext</span> context)</p>
<p>&nbsp;&nbsp;&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:blue">base</span>.Seed(context);</p>
<p>&nbsp;&nbsp;&nbsp; }</p>
<p>}</p>
<p>虽然EF提供了在配置文件中配置策略的方法，如下所示：</p>
<p><span style="color:blue">&lt;</span><span style="color:rgb(163,21,21)">appSettings</span><span style="color:blue">&gt;</span></p>
<p><span style="color:blue">&nbsp;&nbsp;&nbsp; &lt;</span><span style="color:rgb(163,21,21)">add</span><span style="color:red">key</span><span style="color:blue">=</span>&quot;<a target="_blank" name="OLE_LINK2"></a><a target="_blank" name="OLE_LINK1"><span style="color:blue">DatabaseInitializerForType
</span></a><span style="color:blue">EFCodeFirstSample.UserManContext, EFCodeFirstSample</span>&quot;</p>
<p><span style="color:blue">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:red">value</span><span style="color:blue">=</span>&quot;<span style="color:blue">System.Data.Entity.DropCreateDatabaseAlways`1[[EFCodeFirstSample.UserManContext,EFCodeFirstSample]], EntityFramework</span>&quot;<span style="color:blue">
 /&gt;</span></p>
<p><span style="color:blue">&nbsp; &lt;/</span><span style="color:rgb(163,21,21)">appSettings</span><span style="color:blue">&gt;</span></p>
<p>Key必须以DatabaseInitializerForType开始，后边加空&#26684;，之后是context类的全名称，包括带命名空间的类名和所在的程序集名。Value是策略的全名称。可以看见key和value都非常难读，还不如自己写配置来的好。</p>
<p>如果不想使用策略，就可以关闭策略，特别是默认策略。关闭策略的代码如下：</p>
<p><span style="color:blue">public</span> <span style="color:blue">class</span> <span style="color:rgb(43,145,175)">
UserManContext</span> : <span style="color:rgb(43,145,175)">DbContext</span></p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp; <span style="color:blue">public</span> UserManContext()</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : <span style="color:blue">base</span>(<span style="color:rgb(163,21,21)">&quot;USMDBConnectionString&quot;</span>)</p>
<p>&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#2B91AF; background:yellow">Database</span>.SetInitializer&lt;<span style="color:#2B91AF; background:yellow">UserManContext</span>&gt;(<span style="color:blue; background:yellow">null</span>);</p>
<p>&nbsp;&nbsp;&nbsp; } </p>
<p>}</p>
<p>还可以在配置文件中关闭策略，如下：</p>
<p><span style="color:blue">&lt;</span><span style="color:rgb(163,21,21)">add</span><span style="color:red">key</span><span style="color:blue">=</span>&quot;<span style="color:blue">DatabaseInitializerForTypeEFCodeFirstSample.UserManContext, EFCodeFirstSample</span>&quot;</p>
<p><span style="color:blue">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:red">value</span><span style="color:blue">=</span>&quot;<span style="color:blue">Disabled</span>&quot;<span style="color:blue"> /&gt;</span></p>
<p>&nbsp;</p>
<h2>为数据库添加种子数据</h2>
<p>上面提高可以在自定义数据库初始化策略中添加种子数据，下面的示例说明如何添加种子数据：</p>
<p><span style="color:blue">public</span> <span style="color:blue">class</span> <span style="color:rgb(43,145,175)">
USMDBInitializer</span> : <span style="color:rgb(43,145,175)">DropCreateDatabaseAlways</span>&lt;<span style="color:rgb(43,145,175)">UserManContext</span>&gt;</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp; <span style="color:blue">protected</span> <span style="color:blue">override</span>
<span style="color:blue">void</span> Seed(<span style="color:rgb(43,145,175)">UserManContext</span> context)</p>
<p>&nbsp;&nbsp;&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:rgb(43,145,175)">User</span> admin = <span style="color:blue">
new</span> <span style="color:rgb(43,145,175)">User</span>();</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; admin.Name = <span style="color:rgb(163,21,21)">&quot;admin&quot;</span>;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; admin.DisplayName = <span style="color:rgb(163,21,21)">&quot;Administrator&quot;</span>;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; admin.Status = 1;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; admin.LastModDate= <span style="color:#2B91AF; background:yellow">DateTime</span>.Now;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; context.Users.Add(admin);</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:blue">base</span>.Seed(context);</p>
<p>&nbsp;&nbsp;&nbsp; }</p>
<p>}</p>
<p>需要注意的是日期字段，数据库中的日期范围小于.NET中的日期范围，所以必须给一个合适的&#20540;，像DateTime.MinValue这样的&#20540;无法存储到数据库中。可以参考SqlDateTime类型来确定Sql数据库支持的时间范围。</p>
<h2>移除约定</h2>
<p>可以移除在System.Data.Entity.ModelConfiguration.Conventions 命名空间中定义的任何约定。下面的示例移除 PluralizingTableNameConvention。</p>
<p><span style="color:blue">public</span><span style="color:blue">class</span> <span style="color:#2B91AF">
SchoolEntities</span>: <span style="color:#2B91AF">DbContext</span></p>
<p>{</p>
<p>&nbsp; <span style="color:blue">protected</span> <span style="color:blue">override</span>
<span style="color:blue">void</span>OnModelCreating(<span style="color:#2B91AF">DbModelBuilder</span> modelBuilder)</p>
<p>&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp; <span style="color:green">// Configure CodeFirst to ignore PluralizingTableName convention</span></p>
<p>&nbsp;&nbsp;&nbsp; <span style="color:green">// If you keepthis convention, the generated tables
</span></p>
<p>&nbsp;&nbsp;&nbsp; <span style="color:green">// will havepluralized names.</span></p>
<p>&nbsp;&nbsp;&nbsp; modelBuilder.Conventions.Remove&lt;<span style="color:#2B91AF">PluralizingTableNameConvention</span>&gt;();</p>
<p>&nbsp; }</p>
<p>}</p>
<h2>可插入约定</h2>
<p>可插入（自定义）约定目前不受支持，正在针对 EF6 进行开发。</p>
<h1>Code First 数据注释</h1>
<p>通过实体框架Code First，可以使用您自己的域类表示 EF 执行查询、更改跟踪和更新函数所依赖的模型。Code First 利用称为“约定先于配置”的编程模式。这就是说，Code First 将假定您的类遵从 EF 所使用的约定。在这种情况下，EF 将能够找出自己工作所需的详细信息。但是，如果您的类不遵守这些约定，则可以向类中添加配置，以向 EF 提供它需要的信息。</p>
<p>Code First 为您提供了两种方法来向类中添加这些配置。一种方法是使用名为 DataAnnotations 的简单特性，另一种方法是使用 Code First 的Fluent API，该 API 向您提供了在代码中以命令方式描述配置的方法。</p>
<p>本文重点介绍如何使用DataAnnotations（在System.ComponentModel.DataAnnotations 命名空间中）对类进行配置，着重讲述常用的配置。很多 .NET 应用程序（如 ASP.NET MVC）都能够理解DataAnnotations，它允许这些应用程序对客户端验证使用相同的注释。</p>
<p>我将通过Blog 和 Post 这两个简单的类来说明 Code First DataAnnotations。</p>
<p><span style="color:blue">public</span><span style="color:blue">class</span> <span style="color:#2B91AF">
Blog</span></p>
<p>{</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">int</span> Id {
<span style="color:blue">get</span>; <span style="color:blue">set</span>; }</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">string</span> Title {
<span style="color:blue">get</span>; <span style="color:blue">set</span>; }</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">string</span> BloggerName {
<span style="color:blue">get</span>;<span style="color:blue">set</span>; }</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">virtual</span>
<span style="color:#2B91AF">ICollection</span>&lt;<span style="color:#2B91AF">Post</span>&gt; Posts {
<span style="color:blue">get</span>;<span style="color:blue">set</span>; }</p>
<p>}</p>
<p>&nbsp;</p>
<p><span style="color:blue">public</span><span style="color:blue">class</span> <span style="color:#2B91AF">
Post</span></p>
<p>{</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">int</span> Id {
<span style="color:blue">get</span>; <span style="color:blue">set</span>; }</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">string</span> Title {
<span style="color:blue">get</span>; <span style="color:blue">set</span>; }</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:#2B91AF">DateTime</span> DateCreated {
<span style="color:blue">get</span>;<span style="color:blue">set</span>; }</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">string</span> Content {
<span style="color:blue">get</span>;<span style="color:blue">set</span>; }</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">int</span> BlogId {
<span style="color:blue">get</span>; <span style="color:blue">set</span>; }</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:#2B91AF">ICollection</span>&lt;<span style="color:#2B91AF">Comment</span>&gt;Comments {
<span style="color:blue">get</span>; <span style="color:blue">set</span>;}</p>
<p>}</p>
<p>Blog 和 Post 类本身就遵守 Code First 约定，无需调整即可让EF 与之共同使用。但您也可以使用注释向 EF 提供有关类以及类所映射到的数据库的更多信息。</p>
<p>&nbsp;</p>
<h2>键</h2>
<p>实体框架依赖于每个具有键&#20540;的实体，它使用键&#20540;来跟踪实体。Code First 依赖的一个约定是它在每一个 Code First 类中以何种方式表示哪一个属性是键。该约定是查找名为“Id”或类名与“Id”组合在一起（如“BlogId”）的属性。该属性将映射到数据库中的主键列。</p>
<p>Blog 和 Post 类都遵守此约定。但如果它们不遵守呢？如果 Blog 使用名称 PrimaryTrackingKey，甚至使用 foo 呢？如果Code First 找不到符合此约定的属性，它将引发异常，因为实体框架要求必须要有一个键属性。您可以使用键注释来指定要将哪一个属性用作 EntityKey。</p>
<p><span style="color:blue">public</span><span style="color:blue">class</span> <span style="color:#2B91AF">
Blog</span></p>
<p>{</p>
<p>&nbsp; [<span style="color:#2B91AF">Key</span>]</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">int</span> PrimaryTrackingKey {
<span style="color:blue">get</span>;<span style="color:blue">set</span>; }</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">string</span> Title {
<span style="color:blue">get</span>; <span style="color:blue">set</span>; }</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">string</span> BloggerName {
<span style="color:blue">get</span>;<span style="color:blue">set</span>; }</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">virtual</span>
<span style="color:#2B91AF">ICollection</span>&lt;<span style="color:#2B91AF">Post</span>&gt; Posts {
<span style="color:blue">get</span>;<span style="color:blue">set</span>; }</p>
<p>}</p>
<p>如果您在使用Code First 的数据库生成功能，则Blog 表将具有名为 PrimaryTrackingKey 的主键列，该列默认情况下还定义为 Identity。</p>
<p></p>
<p>&nbsp;</p>
<h2>必需</h2>
<p>Required 注释告诉 EF 某一个特定属性是必需的。</p>
<p>在 Title 属性中添加 Required 将强制 EF（和 MVC）确保该属性中包含数据。</p>
<p>[<span style="color:#2B91AF">Required</span>]</p>
<p><span style="color:blue">public</span><span style="color:blue">string</span> Title {
<span style="color:blue">get</span>;<span style="color:blue">set</span>; }</p>
<p>Required 特性将使被映射的属性不可为空来影响生成的数据库。请注意，Title 字段已经更改为“not null”。</p>
<p></p>
<h2>MaxLength 和MinLength</h2>
<p>使用MaxLength 和MinLength 特性，您可以就像对Required 那样指定其他属性验证。</p>
<p>下面是具有长度要求的BloggerName。该示例也说明如何组合特性。</p>
<p>[<span style="color:#2B91AF">MaxLength</span>(10), <span style="color:#2B91AF">
MinLength</span>(5)]</p>
<p><span style="color:blue">public</span><span style="color:blue">string</span> BloggerName {
<span style="color:blue">get</span>;<span style="color:blue">set</span>; }</p>
<p>&nbsp;</p>
<p>MaxLength 注释将通过把属性长度设置为 10 来影响数据库。MinLength属性不会对数据库产生影响。</p>
<p></p>
<h2>NotMapped</h2>
<p>Code First 约定指示具有受支持数据类型的每个属性都要在数据库中有表示。但在您的应用程序中并不总是如此。例如，您可以在 Blog 类中使用一个属性来基于 Title 和BloggerName 字段创建代码。该属性可以动态创建，无需存储。您可以使用 NotMapped 注释来标记不映射到数据库的所有属性，如下面的 BlogCode 属性。</p>
<p>[<span style="color:#2B91AF">NotMapped</span>]</p>
<p><span style="color:blue">public</span><span style="color:blue">string</span> BlogCode</p>
<p>{</p>
<p>&nbsp; <span style="color:blue">get</span></p>
<p>&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp; <span style="color:blue">return</span>Title.Substring(0, 1) &#43; <span style="color:#A31515">
&quot;:&quot;</span> &#43;BloggerName.Substring(0, 1);</p>
<p>&nbsp; }</p>
<p>}</p>
<h2>ComplexType</h2>
<p>跨一组类描述域实体，然后将这些类分层以描述一个完整实体的情况并不少见。例如，您可以向模型中添加一个名为 BlogDetails 的类。</p>
<p><span style="color:blue">public</span><span style="color:blue">class</span> <span style="color:#2B91AF">
BlogDetails</span></p>
<p>{</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:#2B91AF">DateTime</span>? DateCreated {
<span style="color:blue">get</span>;<span style="color:blue">set</span>; }</p>
<p>&nbsp;</p>
<p>&nbsp; [<span style="color:#2B91AF">MaxLength</span>(250)]</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">string</span> Description {
<span style="color:blue">get</span>;<span style="color:blue">set</span>; }</p>
<p>}</p>
<p>请注意，BlogDetails 没有任何键属性类型。在域驱动的设计中，BlogDetails 称为&#20540;对象。实体框架将&#20540;对象称为复杂类型。复杂类型不能自行跟踪。</p>
<p>&nbsp;</p>
<p>但是 BlogDetails 作为 Blog 类中的一个属性，将作为 Blog 对象的一部分被跟踪。为了让 Code First 认识到这一点，您必须将 BlogDetails 类标记为 ComplexType。</p>
<p>[<span style="color:#2B91AF">ComplexType</span>]</p>
<p><span style="color:blue">public</span><span style="color:blue">class</span> <span style="color:#2B91AF">
BlogDetails</span></p>
<p>{</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:#2B91AF">DateTime</span>? DateCreated {
<span style="color:blue">get</span>;<span style="color:blue">set</span>; }</p>
<p>&nbsp; [<span style="color:#2B91AF">MaxLength</span>(250)]</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">string</span> Description {
<span style="color:blue">get</span>;<span style="color:blue">set</span>; }</p>
<p>}</p>
<p>现在，您可以在Blog 类中添加一个属性来表示该博客的 BlogDetails。</p>
<p>&nbsp;&nbsp;&nbsp; public BlogDetails BlogDetail { get; set; }</p>
<p>在数据库中，Blog表将包含该博客的所有属性，包括在其 BlogDetail 属性中所含的属性。默认情况下，每个属性都将添加复杂类型名称前缀 BlogDetail。</p>
<p></p>
<p>另外，有趣的是，虽然DateCreated 属性在类中定义为不可为空的 DateTime，但相关数据库字段是可为空的。如果想影响数据库架构，则必须使用 Required 注释。</p>
<h2>ConcurrencyCheck</h2>
<p>ConcurrencyCheck 注释可用于标记要在用户编辑或删除实体时用于在数据库中进行并发检查的一个或多个属性。如果之前使用 EF 设计器，则这等同于将属性的 ConcurrencyMode 设置为 Fixed。</p>
<p>现在让我们将ConcurrencyCheck 添加到BloggerName 属性，看看它如何工作。</p>
<p>[<span style="color:#2B91AF">ConcurrencyCheck</span>, <span style="color:#2B91AF">
MaxLength</span>(10),<span style="color:#2B91AF">MinLength</span>(5)]&nbsp;&nbsp;&nbsp; </p>
<p><span style="color:blue">public</span><span style="color:blue">string</span> BloggerName {
<span style="color:blue">get</span>;<span style="color:blue">set</span>; }</p>
<p>调用SaveChanges 时，因为BloggerName 字段上具有ConcurrencyCheck 注释，所以在更新中将使用该属性的初始&#20540;。该命令将尝试通过同时依据键&#20540;和 BloggerName 的初始&#20540;进行筛选来查找正确的行。下面是发送到数据库的 UPDATE 命令的关键部分，在其中您可以看到该命令将更新 PrimaryTrackingKey 为 1 且BloggerName 为“Julie”（这是从数据库中检索到该博客时的初始&#20540;）的行。</p>
<p><span style="color:blue">where </span><span style="color:gray">((</span>[PrimaryTrackingKey]<span style="color:gray">=</span> @4<span style="color:gray">)</span>
<span style="color:gray">and</span><span style="color:gray">(</span>[BloggerName]
<span style="color:gray">=</span> @5<span style="color:gray">))</span></p>
<p>@4<span style="color:gray">=</span>1<span style="color:gray">,</span>@5<span style="color:gray">=</span><span style="color:red">N'Julie'</span></p>
<p>如果在此期间有人更改了该博客的博主姓名，则此更新将失败，并引发 DbUpdateConcurrencyException 并且需要处理该异常。</p>
<h2>TimeStamp</h2>
<p>使用rowversion 或timestamp 字段来进行并发检查更为常见。但是比起使用 ConcurrencyCheck 注释，只要属性类型为字节数组，则不如使用更为具体的 TimeStamp 注释。Code First 将Timestamp 属性与ConcurrencyCheck 属性同等对待，但它还将确保 Code First 生成的数据库字段是不可为空的。在一个指定类中，只能有一个 timestamp 属性。</p>
<p>将以下属性添加到Blog 类：</p>
<p>[<span style="color:#2B91AF">Timestamp</span>]</p>
<p><span style="color:blue">public</span><span style="color:#2B91AF">Byte</span>[] TimeStamp {
<span style="color:blue">get</span>;<span style="color:blue">set</span>; }</p>
<p>这样，CodeFirst 将在数据库表中创建一个不可为空的 Timestamp 列。</p>
<p></p>
<h2>表和列</h2>
<p>如果您让Code First 创建数据库，则可能希望更改它创建的表和列的名称。也可以将 Code First 用于现有数据库。但是域中的类和属性的名称并不总是与数据库中表和列的名称相匹配。</p>
<p>我的类名为Blog，按照约定，Code First 将假定此类映射到名为 Blogs 的表。如果不是这样，您可以用 Table 特性指定该表的名称。举例来说，下面的注释指定表名称为 InternalBlogs，同时指定了schema，默认的schema就是dbo。</p>
<p>[<span style="color:#2B91AF">Table</span>(<span style="color:#A31515">&quot;InternalBlogs&quot;</span>,Schema=<span style="color:#A31515">&quot;dbo&quot;</span>)]</p>
<p><span style="color:blue">public</span><span style="color:blue">class</span> <span style="color:#2B91AF">
Blog</span></p>
<p>&nbsp;</p>
<p>Column 注释更适于用来指定被映射列的特性。您可以规定名称、数据类型甚至列出现在表中的顺序。下面是 Column 特性的示例。</p>
<p>[<span style="color:#2B91AF">Column</span>(<span style="color:#A31515">&quot;BlogDescription&quot;</span>,TypeName =
<span style="color:#A31515">&quot;ntext&quot;</span>)]</p>
<p><span style="color:blue">public</span><span style="color:#2B91AF">String</span> Description {
<span style="color:blue">get</span>; <span style="color:blue">set</span>; }</p>
<p>&nbsp;</p>
<p>下面是重新生成后的表。表名称已更改为 InternalBlogs，复杂类型的 Description 列现在是BlogDescription。因为该名称在注释中指定，Code First 不会使用以复杂类型名称作为列名开头的约定。</p>
<p></p>
<h2>DatabaseGenerated</h2>
<p>一个重要的数据库功能是可以使用计算属性。如果您将 Code First 类映射到包含计算列的表，则您可能不想让实体框架尝试更新这些列。但是在插入或更新数据后，您的确需要 EF 从数据库中返回这些&#20540;。您可以使用 DatabaseGenerated 注释与 Computed 枚举一起在您的类中标注这些属性。其他枚举为 None 和Identity。</p>
<p>[<span style="color:#2B91AF">DatabaseGenerated</span>(<span style="color:#2B91AF">DatabaseGeneratedOption</span>.Computed)]</p>
<p><span style="color:blue">public</span><span style="color:#2B91AF">DateTime</span> DateCreated {
<span style="color:blue">get</span>; <span style="color:blue">set</span>; }</p>
<p>&nbsp;</p>
<p>当 Code First生成数据库时，您可以对 byte 或timestamp 列使用此标记，否则您只应该在指向现有数据库时使用，因为 Code First 将不能确定计算列的公式。</p>
<p>您阅读过以上内容，知道默认情况下，整数键属性将成为数据库中的标识键。这与将 DatabaseGenerated 设置为 DatabaseGenerationOption.Identity 是一样的。如果不希望它成为标识键，则可以将该&#20540;设置为 DatabaseGenerationOption.None。</p>
<h2>关系特性：InverseProperty和ForeignKey</h2>
<p>Code First 约定将在您的模型中处理最常用的关系，但是在某些情况下它需要帮助。</p>
<p>在 Blog 类中更改键属性的名称造成它与 Post 的关系出现问题。 </p>
<p>生成数据库时，CodeFirst 会在 Post 类中看到 BlogId 属性并识别出该属性，按照约定，它与类名加“Id”匹配，并作为 Blog 类的外键。但是在此Blog 类中没有 BlogId 属性。解决方法是，在 Post 中创建一个导航属性，并使用 Foreign DataAnnotation 来帮助 CodeFirst 了解如何在两个类之间创建关系（那就是使用 Post.BlogId 属性）以及如何在数据库中指定约束。</p>
<p><span style="color:blue">public</span><span style="color:blue">class</span> <span style="color:#2B91AF">
Post</span></p>
<p>{</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">int</span> Id {
<span style="color:blue">get</span>; <span style="color:blue">set</span>; }</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">string</span> Title {
<span style="color:blue">get</span>; <span style="color:blue">set</span>; }</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:#2B91AF">DateTime</span> DateCreated {
<span style="color:blue">get</span>;<span style="color:blue">set</span>; }</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">string</span> Content {
<span style="color:blue">get</span>;<span style="color:blue">set</span>; }</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">int</span> BlogId {
<span style="color:blue">get</span>; <span style="color:blue">set</span>; }</p>
<p>&nbsp; [<span style="color:#2B91AF">ForeignKey</span>(<span style="color:#A31515">&quot;BlogId&quot;</span>)]</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:#2B91AF">Blog</span> Blog {
<span style="color:blue">get</span>; <span style="color:blue">set</span>; }</p>
<p>}</p>
<p>数据库中的约束显示InternalBlogs.PrimaryTrackingKey 与Posts.BlogId 之间的关系。</p>
<p></p>
<p>&nbsp;</p>
<p>类之间存在多个关系时，将使用 InverseProperty。</p>
<p>在 Post 类中，您可能需要跟踪是谁撰写了博客文章以及谁编辑了它。下面是 Post 类的两个新的导航属性。</p>
<p><span style="color:blue">public</span><span style="color:#2B91AF">Person</span> CreatedBy {
<span style="color:blue">get</span>;<span style="color:blue">set</span>; }</p>
<p><span style="color:blue">public</span><span style="color:#2B91AF">Person</span> UpdatedBy {
<span style="color:blue">get</span>;<span style="color:blue">set</span>; }</p>
<p>&nbsp;</p>
<p>您还需要在这些属性引用的 Person 类中添加内容。Person类具有返回到 Post 的导航属性，一个属性指向该用户撰写的所有文章，一个属性指向该用户更新的所有文章。</p>
<p><span style="color:blue">public</span><span style="color:blue">class</span> <span style="color:#2B91AF">
Person</span></p>
<p>{</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">int</span> Id {
<span style="color:blue">get</span>; <span style="color:blue">set</span>; }</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">string</span> Name {
<span style="color:blue">get</span>; <span style="color:blue">set</span>; }</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:#2B91AF">List</span>&lt;<span style="color:#2B91AF">Post</span>&gt;PostsWritten {
<span style="color:blue">get</span>; <span style="color:blue">set</span>;}</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:#2B91AF">List</span>&lt;<span style="color:#2B91AF">Post</span>&gt;PostsUpdated {
<span style="color:blue">get</span>; <span style="color:blue">set</span>;}</p>
<p>}</p>
<p>Code First 不能自行使这两个类中的属性匹配。Posts 的数据库表应该有一个表示 CreatedBy 人员的外键，有一个表示 UpdatedBy 人员的外键，但是 Code First 将创建四个外键属性：Person_Id、Person_Id1、CreatedBy_Id 和UpdatedBy_Id。(针对每个导航属性创建一个外键)</p>
<p></p>
<p>要解决这些问题，您可以使用 InverseProperty 注释来指定这些属性的匹配。</p>
<p>[<span style="color:#2B91AF">InverseProperty</span>(<span style="color:#A31515">&quot;CreatedBy&quot;</span>)]</p>
<p><span style="color:blue">public</span><span style="color:#2B91AF">List</span>&lt;<span style="color:#2B91AF">Post</span>&gt;PostsWritten {
<span style="color:blue">get</span>; <span style="color:blue">set</span>;}</p>
<p>&nbsp;</p>
<p>[<span style="color:#2B91AF">InverseProperty</span>(<span style="color:#A31515">&quot;UpdatedBy&quot;</span>)]</p>
<p><span style="color:blue">public</span><span style="color:#2B91AF">List</span>&lt;<span style="color:#2B91AF">Post</span>&gt;PostsUpdated {
<span style="color:blue">get</span>; <span style="color:blue">set</span>;}</p>
<p>&nbsp;</p>
<p>因为Person 中的PostsWritten 属性知道这指的是Post 类型，所以它将与 Post.CreatedBy 建立关系。同样，PostsUpdated 也将与 Post.UpdatedBy 建立关系。Code First 不会创建额外的外键。</p>
<p></p>
<h2>总结</h2>
<p>DataAnnotations 不仅可用于在 Code First 类中描述客户端和服务器端验证，还让您能够加强甚至更正 Code First 将基于其约定对您的类所作的假设。使用 DataAnnotations，您不仅能够推动数据库架构生成，还能将 Code First 类映射到预先存在的数据库。</p>
<p>虽然它们都非常灵活，但请记住，DataAnnotations 只提供您经常需要对 Code First 类进行的配置更改。要为一些边缘情况配置类，则应该采用另一种替代配置机制，那就是 Code First 的Fluent API。</p>
<h1>使用Fluent API 配置/映射属性和类型</h1>
<h2>简介</h2>
<p>通常通过重写派生DbContext 上的OnModelCreating 方法来访问Code First Fluent API。以下示例旨在显示如何使用 Fluent API 执行各种任务，您可以将代码复制出来并进行自定义，使之适用于您的模型。</p>
<h2>属性映射</h2>
<p>Property 方法用于为每个属于实体或复杂类型的属性配置特性。Property 方法用于获取给定属性的配置对象。配置对象上的选项特定于要配置的类型；例如，IsUnicode 只能用于字符串属性。</p>
<h2>配置主键</h2>
<p>要显式将某个属性设置为主键，可使用 HasKey 方法。在以下示例中，使用了 HasKey 方法对 OfficeAssignment 类型配置 InstructorID 主键。</p>
<p>modelBuilder.Entity&lt;<span style="color:#2B91AF">OfficeAssignment</span>&gt;().HasKey(t =&gt;t.InstructorID);</p>
<p>&nbsp;</p>
<h2>配置组合主键</h2>
<p>以下示例配置要作为Department 类型的组合主键的DepartmentID 和 Name 属性。</p>
<p>modelBuilder.Entity&lt;<span style="color:#2B91AF">Department</span>&gt;().HasKey(t =&gt;
<span style="color:blue">new</span> { t.DepartmentID, t.Name });</p>
<h2>&nbsp;</h2>
<h2>关闭数&#20540;主键的标识</h2>
<p>以下示例将DepartmentID 属性设置为System.ComponentModel.DataAnnotations.DatabaseGeneratedOption.None，以指示该&#20540;不由数据库生成。</p>
<p>modelBuilder.Entity&lt;<span style="color:#2B91AF">Department</span>&gt;().Property(t =&gt;t.DepartmentID).HasDatabaseGeneratedOption(<span style="color:#2B91AF">DatabaseGeneratedOption</span>.None);</p>
<h2>&nbsp;</h2>
<h2>指定属性的最大长度</h2>
<p>在以下示例中，Name属性不应超过 50 个字符。如果其&#20540;超过 50 个字符，则出现 DbEntityValidationException 异常。如果 Code First 基于此模型创建数据库，它还会将 Name 列的最大长度设置为50 个字符。</p>
<p>modelBuilder.Entity&lt;<span style="color:#2B91AF">Department</span>&gt;().Property(t =&gt;t.Name).HasMaxLength(50);</p>
<p>&nbsp;</p>
<h2>将属性配置为必需</h2>
<p>在下面的示例中，Name属性是必需的。如果不指定 Name，则出现 DbEntityValidationException 异常。如果 Code First 基于此模型创建数据库，则用于存储此属性的列将不可为空。</p>
<p>modelBuilder.Entity&lt;<span style="color:#2B91AF">Department</span>&gt;().Property(t =&gt;t.Name).IsRequired();</p>
<h2>&nbsp;</h2>
<h2>指定不将CLR 属性映射到数据库中的列</h2>
<p>以下示例显示如何指定CLR 类型的属性不映射到数据库中的列。</p>
<p>modelBuilder.Entity&lt;<span style="color:#2B91AF">Department</span>&gt;().Ignore(t =&gt; t.Budget);</p>
<h2>&nbsp;</h2>
<h2>将CLR 属性映射到数据库中的特定列</h2>
<p>以下示例将Name CLR 属性映射到DepartmentName 数据库列。</p>
<p>modelBuilder.Entity&lt;<span style="color:#2B91AF">Department</span>&gt;().Property(t =&gt;t.Name).HasColumnName(<span style="color:#A31515">&quot;DepartmentName&quot;</span>);</p>
<p>&nbsp;</p>
<h2>重命名模型中未定义的外键</h2>
<p>如果您选择不对CLR 类型定义外键，但希望指定它在数据库中应使用的名称，请编码如下：</p>
<p>modelBuilder.Entity&lt;<span style="color:#2B91AF">Course</span>&gt;()</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .HasRequired(c =&gt; c.Department)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .WithMany(t =&gt; t.Courses)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Map(m =&gt; m.MapKey(<span style="color:#A31515">&quot;ChangedDepartmentID&quot;</span>));</p>
<p>&nbsp;</p>
<h2>配置字符串属性是否支持Unicode 内容</h2>
<p>默认情况下，字符串为Unicode（SQLServer 中的nvarchar）。您可以使用IsUnicode 方法指定字符串应为varchar 类型。</p>
<p>modelBuilder.Entity&lt;<span style="color:#2B91AF">Department</span>&gt;()</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Property(t =&gt; t.Name)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .IsUnicode(<span style="color:blue">false</span>);</p>
<p>&nbsp;</p>
<h2>配置数据库列的数据类型</h2>
<p>HasColumnType 方法支持映射到相同基本类型的不同表示。使用此方法并不支持在运行时执行任何数据转换。请注意，IsUnicode 是将列设置为 varchar 的首选方法，因为它与数据库无关。</p>
<p>modelBuilder.Entity&lt;<span style="color:#2B91AF">Department</span>&gt;()</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Property(p =&gt; p.Name)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .HasColumnType(<span style="color:#A31515">&quot;varchar&quot;</span>);</p>
<p>&nbsp;</p>
<h2>配置复杂类型的属性</h2>
<p>对复杂类型配置标量属性有两种方法。</p>
<p>可以对ComplexTypeConfiguration 调用Property。</p>
<p>modelBuilder.ComplexType&lt;<span style="color:#2B91AF">Details</span>&gt;()</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Property(t =&gt; t.Location)</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;.HasMaxLength(20);</p>
<p>&nbsp;</p>
<p>也可以使用点表示法访问复杂类型的属性。</p>
<p>modelBuilder.Entity&lt;<span style="color:#2B91AF">OnsiteCourse</span>&gt;()</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Property(t =&gt; t.Details.Location)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .HasMaxLength(20);</p>
<p>&nbsp;</p>
<h2>将属性配置为用作乐观并发令牌</h2>
<p>要指定实体中的某个属性表示并发令牌，可使用 ConcurrencyCheck 特性或 IsConcurrencyToken 方法。</p>
<p>modelBuilder.Entity&lt;<span style="color:#2B91AF">OfficeAssignment</span>&gt;()</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Property(t =&gt; t.Timestamp)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .IsConcurrencyToken();</p>
<p>&nbsp;</p>
<p>也可以使用IsRowVersion 方法将属性配置为数据库中的行版本。将属性设置为行版本会自动将它配置为乐观并发令牌。</p>
<p>modelBuilder.Entity&lt;<span style="color:#2B91AF">OfficeAssignment</span>&gt;()</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Property(t =&gt; t.Timestamp)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .IsRowVersion();</p>
<p>&nbsp;</p>
<h2>类型映射</h2>
<h2>将类指定为复杂类型</h2>
<p>按约定，没有指定主键的类型将被视为复杂类型。在一些情况下，Code First 不会检测复杂类型（例如，如果您有名为“ID”的属性，但不想将它用作主键）。在此类情况下，您将使用 Fluent API 显式指定某类型是复杂类型。</p>
<p>modelBuilder.ComplexType&lt;<span style="color:#2B91AF">Details</span>&gt;();</p>
<p>&nbsp;</p>
<h2>指定不将CLR 实体类型映射到数据库中的表</h2>
<p>以下示例显示如何排除一个 CLR 类型，使之不映射到数据库中的表。</p>
<p>modelBuilder.Ignore&lt;<span style="color:#2B91AF">OnlineCourse</span>&gt;();</p>
<p>&nbsp;</p>
<h2>将CLR 实体类型映射到数据库中的特定表</h2>
<p>Department 的所有属性都将映射到名为 t_ Department 的表中的列。</p>
<p>modelBuilder.Entity&lt;<span style="color:#2B91AF">Department</span>&gt;().ToTable(<span style="color:#A31515">&quot;t_Department&quot;</span>);</p>
<p>&nbsp;</p>
<p>您也可以这样指定架构名称：</p>
<p>modelBuilder.Entity&lt;<span style="color:#2B91AF">Department</span>&gt;().ToTable(<span style="color:#A31515">&quot;t_Department&quot;</span>,
<span style="color:#A31515">&quot;school&quot;</span>);</p>
<h2>&nbsp;</h2>
<h2>映射“每个层次结构一张表(TPH)”继承</h2>
<p>在 TPH 映射情形下，继承层次结构中的所有类型都将映射到同一个表。鉴别器列用于标识每行的类型。使用 Code First 创建模型时，TPH 参与继承层次结构的类型所用的默认策略。默认情况下，鉴别器列将添加到名为“Discriminator”的表，且层次结构中每个类型的 CLR 类型名称都将用作鉴别器&#20540;。可以使用 Fluent API 修改默认行为。</p>
<p>modelBuilder.Entity&lt;<span style="color:#2B91AF">Course</span>&gt;()</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Map&lt;<span style="color:#2B91AF">Course</span>&gt;(m=&gt; m.Requires(<span style="color:#A31515">&quot;Type&quot;</span>).HasValue(<span style="color:#A31515">&quot;Course&quot;</span>))</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Map&lt;<span style="color:#2B91AF">OnsiteCourse</span>&gt;(m=&gt; m.Requires(<span style="color:#A31515">&quot;Type&quot;</span>).HasValue(<span style="color:#A31515">&quot;OnsiteCourse&quot;</span>));</p>
<p>&nbsp;</p>
<h2>映射“每个类型一张表(TPT)”继承</h2>
<p>在 TPT 映射情形下，所有类型分别映射到不同的表。仅属于某个基类型或派生类型的属性存储在映射到该类型的一个表中。映射到派生类型的表还会存储一个将派生表与基表联接的外键。</p>
<p>modelBuilder.Entity&lt;<span style="color:#2B91AF">Course</span>&gt;().ToTable(<span style="color:#A31515">&quot;Course&quot;</span>);</p>
<p>modelBuilder.Entity&lt;<span style="color:#2B91AF">OnsiteCourse</span>&gt;().ToTable(<span style="color:#A31515">&quot;OnsiteCourse&quot;</span>);</p>
<p>&nbsp;</p>
<h2>映射“每个具体类一张表(TPC)”继承</h2>
<p>在 TPC 映射情形下，层次结构中的所有非抽象类型分别映射到不同的表。映射到派生类的表与映射到数据库中基类的表并无关系。类的所有属性（包括继承属性）都将映射到相应表的列。</p>
<p>调用MapInheritedProperties 方法来配置每个派生类型。MapInheritedProperties 将继承自基类的所有属性重新映射到派生类的表中的新列。</p>
<p>注意：因为属于TPC 继承层次结构的表并不使用同一个主键，因此，如果您让数据库生成的&#20540;具有相同标识种子，则在映射到子类的表中执行插入操作时，会产生重复的实体键。要解决此问题，可以为每个表指定不同的初始种子&#20540;，或关闭主键属性的标识。当使用 Code First 时，标识就是整数键属性的默认&#20540;。</p>
<p>modelBuilder.Entity&lt;<span style="color:#2B91AF">Course</span>&gt;()</p>
<p>&nbsp; .Property(c =&gt; c.CourseID)</p>
<p>&nbsp; .HasDatabaseGeneratedOption(<span style="color:#2B91AF">DatabaseGeneratedOption</span>.None);</p>
<p>&nbsp;</p>
<p>modelBuilder.Entity&lt;<span style="color:#2B91AF">OnsiteCourse</span>&gt;().Map(m =&gt;</p>
<p>{</p>
<p>&nbsp; m.MapInheritedProperties();</p>
<p>&nbsp; m.ToTable(<span style="color:#A31515">&quot;OnsiteCourse&quot;</span>);</p>
<p>});</p>
<p>&nbsp;</p>
<p>modelBuilder.Entity&lt;<span style="color:#2B91AF">OnlineCourse</span>&gt;().Map(m =&gt;</p>
<p>{</p>
<p>&nbsp; m.MapInheritedProperties();</p>
<p>&nbsp; m.ToTable(<span style="color:#A31515">&quot;OnlineCourse&quot;</span>);</p>
<p>});</p>
<p>&nbsp;</p>
<h2>将实体类型的CLR 属性映射到数据库中的多个表（实体拆分）</h2>
<p>实体拆分允许一个实体类型的属性分散在多个表中。在以下示例中，Department 实体拆分到两个表中：Department 和DepartmentDetails。实体拆分通过多次调用 Map 方法将一部分属性映射到特定表。</p>
<p>modelBuilder.Entity&lt;<span style="color:#2B91AF">Department</span>&gt;()</p>
<p>.Map(m=&gt;</p>
<p>{</p>
<p>&nbsp; m.Properties(t =&gt; <span style="color:blue">new</span>{ t.DepartmentID, t.Name });</p>
<p>&nbsp; m.ToTable(<span style="color:#A31515">&quot;Department&quot;</span>);</p>
<p>})</p>
<p>.Map(m=&gt;</p>
<p>{</p>
<p>&nbsp;&nbsp;m.Properties(t=&gt; <span style="color:blue">new</span> { t.DepartmentID, t.Administrator,t.StartDate, t.Budget });</p>
<p>&nbsp; m.ToTable(<span style="color:#A31515">&quot;DepartmentDetails&quot;</span>);</p>
<p>&nbsp;});</p>
<p>&nbsp;</p>
<h2>将多个实体类型映射到数据库中的一个表（表拆分）</h2>
<p>以下示例将使用同一个主键的两个实体类型映射到同一个表。</p>
<p>modelBuilder.Entity&lt;<span style="color:#2B91AF">OfficeAssignment</span>&gt;()</p>
<p>&nbsp; .HasKey(t =&gt; t.InstructorID);</p>
<p>modelBuilder.Entity&lt;<span style="color:#2B91AF">Instructor</span>&gt;()</p>
<p>&nbsp;&nbsp;&nbsp; .HasRequired(t =&gt; t.OfficeAssignment)</p>
<p>&nbsp;&nbsp;&nbsp; .WithRequiredPrincipal(t =&gt;t.Instructor);</p>
<p>modelBuilder.Entity&lt;<span style="color:#2B91AF">Instructor</span>&gt;().ToTable(<span style="color:#A31515">&quot;Instructor&quot;</span>);</p>
<p>modelBuilder.Entity&lt;<span style="color:#2B91AF">OfficeAssignment</span>&gt;().ToTable(<span style="color:#A31515">&quot;Instructor&quot;</span>);</p>
<p>&nbsp;</p>
<h2>使用FluentAPI配置关系</h2>
<h2>简介</h2>
<p>使用FluentAPI配置关系的时候，首先要获得一个EntityTypeConfiguration实例，然后使用其上的HasRequired, HasOptional或者 HasMany方法来指定当前实体参与的关系类型。HasRequired 和HasOptional方法需要一个lambda表达式来指定一个导航属性，HasMany方法需要一个lambda表达式指定一个集合导航属性。然后可以使用WithRequired, WithOptional和WithMany方法来指定反向导航属性，这些方法有不带参数的重载用来指定单向导航。</p>
<p>之后还可以使用HasForeignKey方法来指定外键属性。</p>
<h2>配置【必须-可选】关系（1-0..1）</h2>
<p>OfficeAssignment的键属性不符合命名约定，所以需要我们显式指定。下面的关系表明，OfficeAssignment的Instructor必须存在，但是Instructor的OfficeAssignment不是必须存在的。</p>
<p>modelBuilder.Entity&lt;<span style="color:#2B91AF">OfficeAssignment</span>&gt;()</p>
<p>&nbsp; .HasKey(t =&gt; t.InstructorID);</p>
<p>&nbsp;</p>
<p><span style="color:green">// Map one-to-zero or one relationship</span></p>
<p>modelBuilder.Entity&lt;<span style="color:#2B91AF">OfficeAssignment</span>&gt;()</p>
<p>&nbsp; .HasRequired(t =&gt; t.Instructor)</p>
<p>&nbsp; .WithOptional(t =&gt; t.OfficeAssignment);</p>
<h2>配置两端都是必须的关系（1-1）</h2>
<p>大多数情况下，EF都能推断哪一个类型是依赖项或者是主体项。然而当关系的两端都是必须的或者都是可选的，那么EF就不能识别依赖项或者是主体项。如果关系两端都是必须的，那么在HasRequired方法后使用WithRequiredPrincipal或者WithRequiredDependent来确定主体。如果关系两端都是可选的，那么在HasRequired方法后使用WithOptionalPrincipal和WithOptionalDependent。</p>
<p>&nbsp;</p>
<p>modelBuilder.Entity&lt;<span style="color:#2B91AF">OfficeAssignment</span>&gt;()</p>
<p>&nbsp; .HasKey(t =&gt; t.InstructorID);</p>
<p>&nbsp;</p>
<p>modelBuilder.Entity&lt;<span style="color:#2B91AF">Instructor</span>&gt;()</p>
<p>&nbsp; .HasRequired(t =&gt; t.OfficeAssignment)</p>
<p>&nbsp; .WithRequiredPrincipal(t =&gt; t.Instructor);</p>
<h2>&nbsp;</h2>
<h2>配置多对多关系</h2>
<p>下面的代码配置了一个多对多关系，CodeFirst会使用命名约定来创建连接表，命名约定会使用Course_CourseID 和 Instructor_InstructorID作为连接表的列。</p>
<p>&nbsp;</p>
<p>modelBuilder.Entity&lt;<span style="color:#2B91AF">Course</span>&gt;()</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .HasMany(t =&gt; t.Instructors)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .WithMany(t =&gt; t.Courses);</p>
<p>如果想指定连接表的表名和列名，需要使用Map方法，如下：</p>
<p>modelBuilder.Entity&lt;<span style="color:#2B91AF">Course</span>&gt;()</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .HasMany(t =&gt; t.Instructors)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .WithMany(t =&gt; t.Courses)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Map(m =&gt;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m.ToTable(<span style="color:#A31515">&quot;CourseInstructor&quot;</span>);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m.MapLeftKey(<span style="color:#A31515">&quot;CourseID&quot;</span>);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m.MapRightKey(<span style="color:#A31515">&quot;InstructorID&quot;</span>);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });</p>
<h2>&nbsp;</h2>
<h2>配置单向导航属</h2>
<p>所谓单向导航属性指的是只在关系的一端定义了导航属性。按照约定，CodeFirst将单向导航理解为一对多关系，如果需要一对一的单向导航属性，需要使用如下方法：</p>
<p>modelBuilder.Entity&lt;<span style="color:#2B91AF">OfficeAssignment</span>&gt;()</p>
<p>&nbsp; .HasKey(t =&gt; t.InstructorID);</p>
<p>&nbsp;</p>
<p>modelBuilder.Entity&lt;<span style="color:#2B91AF">Instructor</span>&gt;()</p>
<p>&nbsp; .HasRequired(t =&gt; t.OfficeAssignment)</p>
<p>&nbsp; .WithRequiredPrincipal();</p>
<p>&nbsp;</p>
<h2>启用级联删除</h2>
<p>使用WillCascadeOnDelete方法来配置关系是否允许级联删除。如果外键是不可空的，CodeFirst默认会设置级联删除；否则，不会设置级联删除，当主体被删除后，外键将会被置空。</p>
<p>可以使用如下代码移除此约定：</p>
<p>modelBuilder.Conventions.Remove&lt;<span style="color:#2B91AF">OneToManyCascadeDeleteConvention</span>&gt;();</p>
<p>modelBuilder.Conventions.Remove&lt;<span style="color:#2B91AF">ManyToManyCascadeDeleteConvention</span>&gt;();</p>
<p>下面的代码片段配置为外键不能为空，而且禁用了级联删除。</p>
<p>&nbsp;</p>
<p>modelBuilder.Entity&lt;<span style="color:#2B91AF">Course</span>&gt;()</p>
<p>&nbsp; .HasRequired(t =&gt; t.Department)</p>
<p>&nbsp; .WithMany(t =&gt; t.Courses)</p>
<p>&nbsp; .HasForeignKey(d =&gt; d.DepartmentID)</p>
<p>&nbsp; .WillCascadeOnDelete(<span style="color:blue">false</span>);</p>
<h2>配置组合外键</h2>
<p>下面的代码配置了组合外键</p>
<p>modelBuilder.Entity&lt;<span style="color:#2B91AF">Department</span>&gt;()</p>
<p>&nbsp; .HasKey(d =&gt; <span style="color:blue">new</span>{ d.DepartmentID, d.Name });</p>
<p>&nbsp;</p>
<p><span style="color:green">// Composite foreign key</span></p>
<p>modelBuilder.Entity&lt;<span style="color:#2B91AF">Course</span>&gt;()</p>
<p>&nbsp;&nbsp;&nbsp; .HasRequired(c =&gt; c.Department)</p>
<p>&nbsp;&nbsp;&nbsp; .WithMany(d =&gt; d.Courses)</p>
<p>&nbsp;&nbsp;&nbsp; .HasForeignKey(d =&gt; <span style="color:blue">new</span> { d.DepartmentID, d.DepartmentName });</p>
<h2>&nbsp;</h2>
<h2>配置不符合命名约定的外键属性</h2>
<p>SomeDepartmentID属性不符合外键命名约定，需要使用如下方法将其设置为外键属性：</p>
<p>modelBuilder.Entity&lt;<span style="color:#2B91AF">Course</span>&gt;()</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .HasRequired(c =&gt; c.Department)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .WithMany(d =&gt; d.Courses)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .HasForeignKey(c =&gt;c.SomeDepartmentID);</p>
<p>&nbsp;</p>
<h1>定义DbSet</h1>
<h2>DbContext 使用DbSet 属性</h2>
<p>Code First 示例中显示的常见情况是让 DbContext 为模型实体类型使用公共自动 DbSet 属性。例如：</p>
<p><span style="color:blue">public</span><span style="color:blue">class</span> <span style="color:#2B91AF">
BloggingContext</span>: <span style="color:#2B91AF">DbContext</span></p>
<p>{</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:#2B91AF">DbSet</span>&lt;<span style="color:#2B91AF">Blog</span>&gt;Blogs {
<span style="color:blue">get</span>; <span style="color:blue">set</span>;}</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:#2B91AF">DbSet</span>&lt;<span style="color:#2B91AF">Post</span>&gt;Posts {
<span style="color:blue">get</span>; <span style="color:blue">set</span>;}</p>
<p>}</p>
<p>&nbsp;</p>
<p>在 CodeFirst 模式下使用时，这会将 Unicorn、Princess、LadyInWaiting 和Castle 配置为实体类型，也将配置可从这些类型访问的其他类型。此外，DbContext 还将自动对其中每个属性调用 setter 以设置相应 DbSet 的实例。</p>
<h2>DbContext 使用IDbSet 属性</h2>
<p>在创建 mock或 fake 等情况下，更适合使用接口来声明 set 属性。在这些情况下，可使用 IDbSet 接口替代 DbSet。例如：</p>
<p><span style="color:blue">public</span><span style="color:blue">class</span> <span style="color:#2B91AF">
BloggingContext</span>: <span style="color:#2B91AF">DbContext</span></p>
<p>{</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:#2B91AF">IDbSet</span>&lt;<span style="color:#2B91AF">Blog</span>&gt;Blogs {
<span style="color:blue">get</span>; <span style="color:blue">set</span>;}</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:#2B91AF">IDbSet</span>&lt;<span style="color:#2B91AF">Post</span>&gt;Posts {
<span style="color:blue">get</span>; <span style="color:blue">set</span>;}</p>
<p>}</p>
<p>&nbsp;</p>
<p>此上下文的工作方式与对其 set 属性使用DbSet 类的上下文完全相同。</p>
<h2>DbContext 使用只读set 属性</h2>
<p>如果不希望为DbSet 或 IDbSet 属性公开公共 setter，可以改为创建只读属性并自建 set 实例。例如：</p>
<p><span style="color:blue">public</span><span style="color:blue">class</span> <span style="color:#2B91AF">
BloggingContext</span>: <span style="color:#2B91AF">DbContext</span></p>
<p>{</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:#2B91AF">DbSet</span>&lt;<span style="color:#2B91AF">Blog</span>&gt;Blogs</p>
<p>&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp; <span style="color:blue">get</span> { <span style="color:blue">return</span> Set&lt;<span style="color:#2B91AF">Blog</span>&gt;();}</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:#2B91AF">DbSet</span>&lt;<span style="color:#2B91AF">Post</span>&gt;Posts</p>
<p>&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp; <span style="color:blue">get</span> { <span style="color:blue">return</span> Set&lt;<span style="color:#2B91AF">Post</span>&gt;();}</p>
<p>&nbsp; }</p>
<p>}</p>
<p>请注意，DbContext将缓存从 Set 方法返回的 DbSet 实例，以便每次调用其中每个属性时都返回同一实例。</p>
<p>搜索 CodeFirst 实体类型的工作方式与搜索具有公共 getter 和setter 的属性相同。</p>
<h2>DbContext使用注意事项</h2>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随着越来越多的对象和他们的引用进入内存，DbContext的内存消耗可能会迅速增长，这将会引起性能问题。</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当不再使用context对象的时候，一定要释放它。</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果一个异常使得context进入了一个不可恢复的状态，整个应用可能会终止。</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;长时间使用的context会增加并发冲突的可能。</p>
<h2>DbSet使用注意事项</h2>
<p>DbSet总是针对数据库执行查询，即使要查询的数据已经在上下文中，下面几种情况下会执行数据库查询。</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行foreach</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调用ToArray, ToDictionary, ToList.</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在最外层查询调用LINQ操作符First，Any等等。</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DbSet的扩展方法Load，DbEntityEntry.Reload，Database.ExecuteSqlCommand.</p>
<p>当数据库返回查询结果的时候，如果结果集中的对象在context中不存在，那么就会将对象attach到上下文中。如果对象已经存在（根据id来判断），那么就会返回在上下文中已经存在的对象，数据库的&#20540;不会覆盖当前对象database values。在这种情况下，如果我们长时间持有DbContext，那么我们在每次查询的时候得到就很有可能不是最新版本的对象。</p>
<p>在执行一个查询的时候，上下文中新添加但是还没有保存的对象不会作为查询结果返回，如果想访问这些对象，需要访问Local属性。下面是关于local属性的备注</p>
<p>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Local属性不只是包含新添加的对象，它包含所有已经加载到context中的对象。</p>
<p>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Local属性不包含那些已经被Remove的对象（上下文中remove了，但是还在数据库中）</p>
<p>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查询结果永远反应数据库的真实数据，在上下文中被Remove了但是还没有在数据库删除的对象，仍然可以查询到。DbContext.ChangeTracker属性提供了DbChangeTracker的实例，该实例的Entries属性返回一个DbEntityEntry集合，可以找到所有当前上下文中跟踪的实体及其状态信息。</p>
<p>有时候在查询大量实体并只进行只读操作的时候，实体跟踪是没有任何意义的，禁用实体跟踪会提高查询性能，可以AsNoTracking方法来禁用实体跟踪，例如：</p>
<p><span style="color:blue">using</span>(<span style="color:blue">var</span> context =
<span style="color:blue">new</span><span style="color:#2B91AF">BloggingContext</span>())</p>
<p>{</p>
<p>&nbsp; <span style="color:green">// Query for allblogs without tracking them</span></p>
<p>&nbsp; <span style="color:blue">var</span> blogs1 =context.Blogs.AsNoTracking();</p>
<p>&nbsp;</p>
<p>&nbsp; <span style="color:green">// Query for someblogs without tracking them</span></p>
<p>&nbsp; <span style="color:blue">var</span> blogs2 =context.Blogs</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Where(b =&gt;b.Name.Contains(<span style="color:#A31515">&quot;.NET&quot;</span>))</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .AsNoTracking()</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .ToList();</p>
<p>}</p>
<p>&nbsp;</p>
<h2>根据主键查找实体</h2>
<p>DbSet.Find方法会根据主键来查找被上下文跟踪的实体。如果上下文中不存在此对象，那么将会对数据库进行查询来查找实体，如果没有找到实体，则返回null。Find方法可以查询到刚刚添加到上下文但是还没有被保存到数据库的实体，这与LINQ查询不同。</p>
<p>使用 Find 方法时必须考虑：</p>
<p>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果对象没有在缓存中，则 Find 没有优势，但语法仍比按键进行查询简单。</p>
<p>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果启用自动检测更改，则根据模型的复杂性以及对象缓存中的实体数量，Find 方法的成本可能会增加一个数量级，甚至更多。</p>
<p>此外，请注意Find 仅返回要查找的实体，它不会自动加载未在对象缓存中的关联实体。如果需要检索关联实体，可通过预先加载使用按键查询。</p>
<h1>创建和修改关系</h1>
<p>对于拥有外键属性的关系，修改关系是非常简单的，如下：</p>
<p>course.DepartmentID =newCourse.DepartmentID;</p>
<p>下面的代码通过将外键设置为 null 删除了关系。请注意，外键属性必须可以为 Null。</p>
<p>course.DepartmentID = null;</p>
<p>注意：如果引用处于已添加状态（在本例中为 course 对象），在调用 SaveChanges 之前，引用导航属性将不与新对象的键&#20540;同步。由于对象上下文在键&#20540;保存前不包含已添加对象的永久键，因此不发生同步。</p>
<p>通过将一个新对象分配给导航属性。下面的代码在 course 和department 之间创建关系。如果对象附加到上下文，course 也会添加到 department.Courses 集合中，course 对象的相应的外键属性设置为 department 的键属性&#20540;。</p>
<p>course.Department =department;</p>
<p>要删除该关系，请将导航属性设置为 null。如果使用的是基于 .NET 4.0 的实体框架，则需要先加载相关端，然后再将其设置为 Null。例如：</p>
<p>context.Entry(course).Reference(c=&gt; c.Department).Load();</p>
<p>course.Department = null;</p>
<p>从实体框架5.0（它基于 .NET 4.5）开始，不必加载相关端就可以将关系设置为 Null。也可以使用以下方法将当前&#20540;设置为 Null。</p>
<p>context.Entry(course).Reference(c=&gt; c.Department).CurrentValue = null;</p>
<p>通过在实体集合中删除或添加对象。例如，可以将 Course 类型的对象添加到 department.Courses 集合中。此操作将在特定 course 和特定 department 之间创建关系。如果对象附加到上下文，course 对象的 department 引用和外键属性将设置为相应的 department。</p>
<p>department.Courses.Add(newCourse);</p>
<p>此处，如果course的departmentid不能为空，则可能会出现错误，对department.Courses集合不能有删除course的操作，否则会出现错误。因为如果从集合中移除了course，在SaveChanges过程中把该过程识别为更新关系，而那些被删除的course的departmentid又不能为空，所以save不会成功。</p>
<p>通过使用 ChangeRelationshipState方法更改两个实体对象间指定关系的状态。此方法是处理 N 层应用程序和独立关联 时最常用的方法（不能用于外键关联）。此外，要使用此方法，必须下拉到 ObjectContext，如下例所示。</p>
<p>在下面的示例中，Instructor和 Course 之间存在多对多关系。调用 ChangeRelationshipState 方法并传递 EntityState.Added 参数，使 SchoolContext 知道在这两个对象间添加了关系。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((IObjectContextAdapter)context).ObjectContext.ObjectStateManager.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ChangeRelationshipState(course, instructor, c =&gt; c.Instructor,EntityState.Added);&nbsp;&nbsp;
</p>
<p>请注意，如果是更新（而不仅是添加）关系，添加新关系后必须删除旧关系：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((IObjectContextAdapter)context).ObjectContext. ObjectStateManager.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ChangeRelationshipState(course, oldInstructor, c =&gt; c.Instructor,EntityState.Deleted);&nbsp;&nbsp;&nbsp;
</p>
<h2>同步FK 和导航属性之间的更改</h2>
<p>使用上述方法中的一种更改附加到上下文的对象的关系时，实体框架需要保持外键、引用和集合同步。实体框架使用代理自动管理 POCO 实体的这种同步（也称为关系修复）。</p>
<p>如果不通过代理使用POCO 实体，则必须确保调用 DetectChanges 方法同步上下文中的相关对象。请注意，下面的 API 会自动触发 DetectChanges 调用。</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DbSet.Add</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DbSet.Find</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DbSet.Remove</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DbSet.Local</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DbContext.SaveChanges</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DbSet.Attach</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DbContext.GetValidationErrors</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DbContext.Entry</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DbChangeTracker.Entries</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对 DbSet 执行 LINQ 查询</p>
<p>如果context中有很多实体，而且你正在多次调用上述方法，那么就会造成很大的性能影响。可以使用下面的代码来的代码禁用自动检测：</p>
<p><span style="color:blue">using</span>(<span style="color:blue">var</span> context =
<span style="color:blue">new</span><span style="color:#2B91AF">BloggingContext</span>())</p>
<p>{</p>
<p>&nbsp; <span style="color:blue">try</span></p>
<p>&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp;context.Configuration.AutoDetectChangesEnabled = <span style="color:blue">false</span>;</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp; <span style="color:green">// Make manycalls in a loop</span></p>
<p>&nbsp;&nbsp;&nbsp; <span style="color:blue">foreach</span> (<span style="color:blue">var</span> blog
<span style="color:blue">in</span>aLotOfBlogs)</p>
<p>&nbsp;&nbsp;&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; context.Blogs.Add(blog);</p>
<p>&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp; }</p>
<p>&nbsp; <span style="color:blue">finally</span></p>
<p>&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp;context.Configuration.AutoDetectChangesEnabled = <span style="color:blue">true</span>;</p>
<p>&nbsp; }</p>
<p>}</p>
<p>除了以上方法，还可以调用context.ChangeTracker.DetectChanges方法来显式检测变化。需要小心使用这些高级方法，否则很容易在你的程序里引入微妙的bug。</p>
<h1>加载相关对象</h1>
<h2>预加载（EagerlyLoading）</h2>
<p>预加载表示在查询某类实体时一起加载相关实体，这是使用Include方法完成的，如下：</p>
<p><span style="color:blue">using</span>(<span style="color:blue">var</span> context =
<span style="color:blue">new</span><span style="color:#2B91AF">BloggingContext</span>())</p>
<p>{</p>
<p>&nbsp; <span style="color:green">// Load all blogsand related posts</span></p>
<p>&nbsp; <span style="color:blue">var</span> blogs1 =context.Blogs</p>
<p>.Include(b=&gt; b.Posts)</p>
<p>.ToList();</p>
<p>&nbsp;</p>
<p>&nbsp; <span style="color:green">// Load one blogsand its related posts</span></p>
<p>&nbsp; <span style="color:blue">var</span> blog1 =context.Blogs</p>
<p>.Where(b=&gt; b.Name == <span style="color:#A31515">&quot;ADO.NET Blog&quot;</span>)</p>
<p>.Include(b=&gt; b.Posts)</p>
<p>.FirstOrDefault();</p>
<p>&nbsp;</p>
<p>&nbsp; <span style="color:green">// Load all blogsand related posts </span></p>
<p>&nbsp; <span style="color:green">// using a stringto specify the relationship</span></p>
<p>&nbsp; <span style="color:blue">var</span> blogs2 =context.Blogs</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Include(<span style="color:#A31515">&quot;Posts&quot;</span>)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .ToList();</p>
<p>&nbsp;</p>
<p>&nbsp; <span style="color:green">// Load one blogand its related posts </span></p>
<p>&nbsp; <span style="color:green">// using a stringto specify the relationship</span></p>
<p>&nbsp; <span style="color:blue">var</span> blog2 =context.Blogs</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Where(b =&gt; b.Name == <span style="color:#A31515">&quot;ADO.NET Blog&quot;</span>)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Include(<span style="color:#A31515">&quot;Posts&quot;</span>)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .FirstOrDefault();</p>
<p>}</p>
<p>注意：Include方法是一个扩展方法，在System.Data.Entity命名空间下，确保引用了此命名空间。</p>
<h2>多级预加载</h2>
<p>下面的代码显示了如何加载多级实体。</p>
<p><span style="color:blue">using</span>(<span style="color:blue">var</span> context =
<span style="color:blue">new</span><span style="color:#2B91AF">BloggingContext</span>())</p>
<p>{</p>
<p>&nbsp; <span style="color:green">// Load all blogs,all related posts, and all related comments</span></p>
<p>&nbsp; <span style="color:blue">var</span> blogs1 =context.Blogs</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Include(b =&gt;b.Posts.Select(p =&gt; p.Comments))</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .ToList();</p>
<p>&nbsp;</p>
<p>&nbsp; <span style="color:green">// Load all userstheir related profiles, and related avatar</span></p>
<p>&nbsp; <span style="color:blue">var</span> users1 =context.Users</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Include(u =&gt;u.Profile.Avatar)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .ToList();</p>
<p>&nbsp;</p>
<p>&nbsp; <span style="color:green">// Load all blogs,all related posts, and all related comments
</span></p>
<p>&nbsp; <span style="color:green">// using a stringto specify the relationships</span></p>
<p>&nbsp; <span style="color:blue">var</span> blogs2 =context.Blogs</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Include(<span style="color:#A31515">&quot;Posts.Comments&quot;</span>)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .ToList();</p>
<p>&nbsp;</p>
<p>&nbsp; <span style="color:green">// Load all userstheir related profiles, and related avatar
</span></p>
<p>&nbsp; <span style="color:green">// using a stringto specify the relationships</span></p>
<p>&nbsp; <span style="color:blue">var</span> users2 =context.Users</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Include(<span style="color:#A31515">&quot;Profile.Avatar&quot;</span>)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .ToList();</p>
<p>}</p>
<p>当前不支持在关联实体上进行查询，Include方法总是加载所有关联实体。</p>
<h2>惰性加载</h2>
<p>惰性加载指的是当第一访问导航属性的时候自动从数据库加载相关实体。这种特性是由代理类实现的，代理类派生自实体类，并重写了导航属性。所以我们的实体类的导航属性就必须标记为virtual，如下：</p>
<p><span style="color:blue">public</span><span style="color:blue">class</span> <span style="color:#2B91AF">
Blog</span></p>
<p>{</p>
<p>&nbsp;&nbsp;<span style="color:blue">public</span> <span style="color:blue">int</span> ID {
<span style="color:blue">get</span>; <span style="color:blue">set</span>; }</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">string</span> Title {
<span style="color:blue">get</span>; <span style="color:blue">set</span>; }</p>
<p>&nbsp;&nbsp;<span style="color:blue">public</span> <span style="color:blue">virtual</span>
<span style="color:#2B91AF">ICollection</span>&lt;<span style="color:#2B91AF">Post</span>&gt;Posts {
<span style="color:blue">get</span>; <span style="color:blue">set</span>;}</p>
<p>}</p>
<p>可以对指定实体关闭惰性加载，如下：</p>
<p><span style="color:blue">public</span><span style="color:blue">class</span> <span style="color:#2B91AF">
Blog</span></p>
<p>{</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">int</span> ID {
<span style="color:blue">get</span>; <span style="color:blue">set</span>; }</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:blue">string</span> Title {
<span style="color:blue">get</span>; <span style="color:blue">set</span>; }</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:#2B91AF">ICollection</span>&lt;<span style="color:#2B91AF">Post</span>&gt;Posts {
<span style="color:blue">get</span>; <span style="color:blue">set</span>;}</p>
<p>}</p>
<p>也可以对所有实体关闭惰性加载，如下：</p>
<p><span style="color:blue">public</span><span style="color:blue">class</span> <span style="color:#2B91AF">
BloggingContext</span>: <span style="color:#2B91AF">DbContext</span></p>
<p>{</p>
<p>&nbsp; <span style="color:blue">public</span>BloggingContext()</p>
<p>&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp; <span style="color:blue">this</span>.Configuration.LazyLoadingEnabled= <span style="color:blue">
false</span>;</p>
<p>&nbsp; }</p>
<p>}</p>
<h2>显式加载</h2>
<p>即使关闭了惰性加载，我们仍然可以通过显式调用来延迟加载相关实体，这是通过调用DbEntityEntry上的相关方法做到的，如下：</p>
<p><span style="color:blue">using</span>(<span style="color:blue">var</span> context =
<span style="color:blue">new</span><span style="color:#2B91AF">BloggingContext</span>())</p>
<p>{</p>
<p>&nbsp; <span style="color:blue">var</span> post =context.Posts.Find(2);</p>
<p>&nbsp;</p>
<p>&nbsp; <span style="color:green">// Load the blogrelated to a given post</span></p>
<p>&nbsp; context.Entry(post).Reference(p =&gt; p.Blog).Load();</p>
<p>&nbsp;</p>
<p>&nbsp; <span style="color:green">// Load the blogrelated to a given post using a string
</span></p>
<p>&nbsp; context.Entry(post).Reference(<span style="color:#A31515">&quot;Blog&quot;</span>).Load();</p>
<p>&nbsp;</p>
<p>&nbsp; <span style="color:blue">var</span> blog =context.Blogs.Find(1);</p>
<p>&nbsp;</p>
<p>&nbsp; <span style="color:green">// Load the postsrelated to a given blog</span></p>
<p>&nbsp; context.Entry(blog).Collection(p =&gt;p.Posts).Load();</p>
<p>&nbsp;</p>
<p>&nbsp; <span style="color:green">// Load the postsrelated to a given blog </span></p>
<p>&nbsp; <span style="color:green">// using a stringto specify the relationship</span></p>
<p>&nbsp; context.Entry(blog).Collection(<span style="color:#A31515">&quot;Posts&quot;</span>).Load();</p>
<p>}</p>
<p>&nbsp;</p>
<p>注意：在外键关联中，加载依赖对象的相关端时，将根据内存中当前的相关外键&#20540;加载相关对象：</p>
<p><span style="color:#00B050">// Get thecourse where currently DepartmentID = 1.</span></p>
<p>Course course2 =context.Courses.First(c=&gt;c.DepartmentID == 2);</p>
<p>&nbsp;<span style="color:#00B050">// UseDepartmentID foreign key property </span></p>
<p><span style="color:#00B050">// to change theassociation.</span></p>
<p>course2.DepartmentID = 3;</p>
<p>&nbsp;<span style="color:#00B050">// Load therelated Department where DepartmentID = 3</span></p>
<p>context.Entry(course).Reference(c=&gt; c.Department).Load();</p>
<p>在独立关联中，基于当前数据库中的外键&#20540;查询依赖对象的相关端。不过，如果修改了关系，并且依赖对象的引用属性指向对象上下文中加载的不同主对象，实体框架将尝试创建关系，就像它在客户端定义的那样。</p>
<p>Query方法提供了在加载相关实体的时候应用过滤条件的功能，引用导航属和集合导航属性都支持Query方法，但是大部分情况下都会针对集合导航属性使用Query方法，达到只加载部分相关实体的功能，如下：</p>
<p><span style="color:blue">using</span>(<span style="color:blue">var</span> context =
<span style="color:blue">new</span><span style="color:#2B91AF">BloggingContext</span>())</p>
<p>{</p>
<p>&nbsp; <span style="color:blue">var</span> blog =context.Blogs.Find(1);</p>
<p>&nbsp;</p>
<p>&nbsp; <span style="color:green">// Load the postswith the 'entity-framework' tag related to a given blog</span></p>
<p>&nbsp; context.Entry(blog)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Collection(b =&gt; b.Posts)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Query()</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Where(p =&gt; p.Title.Contains(<span style="color:#A31515">&quot;entity-framework&quot;</span>))</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Load();</p>
<p>&nbsp;</p>
<p>&nbsp; <span style="color:green">// Load the postswith the 'entity-framework' tag related to a given blog
</span></p>
<p>&nbsp; <span style="color:green">// using a stringto specify the relationship </span>
</p>
<p>&nbsp; context.Entry(blog)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Collection(<span style="color:#A31515">&quot;Posts&quot;</span>)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Query()</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Cast&lt;<span style="color:#2B91AF">Post</span>&gt;()</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Where(p =&gt; p.Title.Contains(<span style="color:#A31515">&quot;entity-framework&quot;</span>))</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Load();</p>
<p>}</p>
<p>注意，使用显式加载的时候，最好关闭惰性加载，避免引起混乱。Load方法是一个扩展方法，记得引用命名空间System.Data.Entity.DbExtensions</p>
<p>使用Query查询相关实体个数，而不用加载相关实体，如下：</p>
<p><span style="color:blue">using</span>(<span style="color:blue">var</span> context =
<span style="color:blue">new</span><span style="color:#2B91AF">BloggingContext</span>())</p>
<p>{</p>
<p>&nbsp; <span style="color:blue">var</span> blog =context.Blogs.Find(1);</p>
<p>&nbsp;</p>
<p>&nbsp; <span style="color:green">// Count how manyposts the blog has </span></p>
<p>&nbsp; <span style="color:blue">var</span> postCount= context.Entry(blog)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Collection(b =&gt;b.Posts)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Query()</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Count();</p>
<p>}</p>
<p>&nbsp;</p>
<h1>使用代理</h1>
<p>为 POCO 实体类型创建实例时，实体框架常常为充当实体代理的动态生成的派生类型创建实例。此代理重写实体的某些虚拟属性，这样可在访问属性时插入挂钩，从而自动执行操作。例如，此机制用于支持关系的延迟加载。</p>
<h2>禁止创建代理</h2>
<p>有时需要禁止实体框架创建代理实例。例如，人们通常认为序列化非代理实例要比序列化代理实例容易得多。可通过清除 ProxyCreationEnabled 标记来关闭代理创建功能。上下文的构造函数便是可执行此操作的一个位置。例如：</p>
<p><span style="color:blue">public</span><span style="color:blue">class</span> <span style="color:#2B91AF">
BloggingContext</span>: <span style="color:#2B91AF">DbContext</span></p>
<p>{</p>
<p>&nbsp; <span style="color:blue">public</span>BloggingContext()</p>
<p>&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp; <span style="color:blue">this</span>.Configuration.ProxyCreationEnabled= <span style="color:blue">
false</span>;</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:#2B91AF">DbSet</span>&lt;<span style="color:#2B91AF">Blog</span>&gt;Blogs {
<span style="color:blue">get</span>; <span style="color:blue">set</span>;}</p>
<p>&nbsp; <span style="color:blue">public</span> <span style="color:#2B91AF">DbSet</span>&lt;<span style="color:#2B91AF">Post</span>&gt;Posts {
<span style="color:blue">get</span>; <span style="color:blue">set</span>;}</p>
<p>}</p>
<p>请注意，在无需代理执行任何操作的情况下，EF 不会为类型创建代理。这意味着，也可以通过使用封装和/或没有虚拟属性的类型，避免生成代理。</p>
<h2>添加新实体</h2>
<p>使用DbSet.Add方法添加实体</p>
<p><span style="color:blue">using</span>(<span style="color:blue">var</span> context =
<span style="color:blue">new</span><span style="color:#2B91AF">BloggingContext</span>())</p>
<p>{</p>
<p>&nbsp; <span style="color:blue">var</span> blog = <span style="color:blue">new</span>
<span style="color:#2B91AF">Blog</span> { Name = <span style="color:#A31515">&quot;ADO.NET Blog&quot;</span> };</p>
<p>&nbsp; context.Blogs.Add(blog);</p>
<p>&nbsp; context.SaveChanges();</p>
<p>}</p>
<p>&nbsp;</p>
<p>修改Entry的State来添加实体</p>
<p><span style="color:blue">using</span>(<span style="color:blue">var</span> context =
<span style="color:blue">new</span><span style="color:#2B91AF">BloggingContext</span>())</p>
<p>{</p>
<p>&nbsp; <span style="color:blue">var</span> blog = <span style="color:blue">new</span>
<span style="color:#2B91AF">Blog</span> { Name = <span style="color:#A31515">&quot;ADO.NET Blog&quot;</span> };</p>
<p>&nbsp; context.Entry(blog).State =EntityState.Added;</p>
<p>&nbsp; context.SaveChanges();</p>
<p>}</p>
<p>&nbsp;</p>
<p>设置导航属性来添加实体</p>
<p><span style="color:blue">using</span>(<span style="color:blue">var</span> context =
<span style="color:blue">new</span><span style="color:#2B91AF">BloggingContext</span>())</p>
<p>{</p>
<p>&nbsp; <span style="color:green">// Add a new Userby setting a reference from a tracked Blog</span></p>
<p>&nbsp; <span style="color:blue">var</span> blog =context.Blogs.Find(1);</p>
<p>&nbsp; blog.Owner = <span style="color:blue">new</span>User { UserName = <span style="color:#A31515">
&quot;johndoe1987&quot;</span> };</p>
<p>&nbsp;</p>
<p>&nbsp; <span style="color:green">// Add a new Postby adding to the collection of a tracked Blog</span></p>
<p>&nbsp; <span style="color:blue">var</span> blog =context.Blogs.Find(2);</p>
<p>&nbsp; blog.Posts.Add(<span style="color:blue">new</span><span style="color:#2B91AF">Post</span> { Name =
<span style="color:#A31515">&quot;Howto Add Entities&quot;</span> });</p>
<p>&nbsp;</p>
<p>&nbsp; context.SaveChanges();</p>
<p>}</p>
<p>所有被添加到上下文中的实体的引用实体，如果没有被跟踪，就会被当作新实体添加到上下文中，并在调用SaveChanges方法后被保存到数据库。</p>
<h2>附加实体到上下文</h2>
<p>如果实体在数据库中存在，但是没有被上下文跟踪，可是使用DbSet.Attach方法将其附加到上下文，附加之后，实体处于Unchanged状态。处于Unchanged状态的实体不会参与SaveChanges的逻辑。</p>
<p><span style="color:blue">var</span>existingBlog = <span style="color:blue">new</span>
<span style="color:#2B91AF">Blog</span>{ BlogId = 1, Name = <span style="color:#A31515">
&quot;ADO.NET Blog&quot;</span>};</p>
<p>&nbsp;</p>
<p><span style="color:blue">using</span>(<span style="color:blue">var</span> context =
<span style="color:blue">new</span><span style="color:#2B91AF">BloggingContext</span>())</p>
<p>{</p>
<p>&nbsp; context.Blogs.Attach(existingBlog);</p>
<p>&nbsp;</p>
<p>&nbsp; <span style="color:green">// Do some morework... </span></p>
<p>&nbsp;</p>
<p>&nbsp; context.SaveChanges();</p>
<p>}</p>
<p>设置DbEntityEntry对象的State属性，也可以附加对象到上下文中，如下：</p>
<p><span style="color:blue">var</span>existingBlog = <span style="color:blue">new</span>
<span style="color:#2B91AF">Blog</span>{ BlogId = 1, Name = <span style="color:#A31515">
&quot;ADO.NET Blog&quot;</span>};</p>
<p>&nbsp;</p>
<p><span style="color:blue">using</span>(<span style="color:blue">var</span> context =
<span style="color:blue">new</span><span style="color:#2B91AF">BloggingContext</span>())</p>
<p>{</p>
<p>&nbsp; context.Entry(existingBlog).State =EntityState.Unchanged;</p>
<p>&nbsp;</p>
<p>&nbsp; <span style="color:green">// Do some morework... </span></p>
<p>&nbsp;</p>
<p>&nbsp; context.SaveChanges();</p>
<p>}</p>
<p>使用上述两种方法附加到上下文的实体如果还引用其他实体，那么这些实体也会被附加到上下文中，状态为Unchanged</p>
<p>使用如下方法附加一个存在于数据库，但是还没有附加到上下文的已修改实体：</p>
<p><span style="color:blue">var</span>existingBlog = <span style="color:blue">new</span>
<span style="color:#2B91AF">Blog</span>{ BlogId = 1, Name = <span style="color:#A31515">
&quot;ADO.NET Blog&quot;</span>};</p>
<p>&nbsp;</p>
<p><span style="color:blue">using</span>(<span style="color:blue">var</span> context =
<span style="color:blue">new</span><span style="color:#2B91AF">BloggingContext</span>())</p>
<p>{</p>
<p>&nbsp; context.Entry(existingBlog).State =EntityState.Modified;</p>
<p>&nbsp;</p>
<p>&nbsp; <span style="color:green">// Do some morework... </span></p>
<p>&nbsp;</p>
<p>&nbsp; context.SaveChanges();</p>
<p>}</p>
<p>如果把一个实体的状态置为Modified，那么该实体的所有属性都将被标记为已更改状态，当SaveChanges被调用时，所有的属性&#20540;都将被保存到数据库。如果不想保存所有&#20540;，可以单独为每个想要修改的属性设置IsModified属性，如下：</p>
<p><span style="color:blue">using</span>(<span style="color:blue">var</span> context =
<span style="color:blue">new</span><span style="color:#2B91AF">BloggingContext</span>())</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp; <span style="color:blue">var</span> blog =context.Blogs.Find(1);</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp; context.Entry(blog).Property(u =&gt;u.Name).IsModified = <span style="color:blue">
true</span>;</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp; <span style="color:green">// Use a stringfor the property name</span></p>
<p>&nbsp;&nbsp;&nbsp; context.Entry(blog).Property(<span style="color:#A31515">&quot;Name&quot;</span>).IsModified =
<span style="color:blue">true</span>;</p>
<p>}</p>
<p>&nbsp;</p>
<p>如果该实体还引用其他未被跟踪实体，那么这些实体将会作为Unchanged状态的实体附加到上下文。如果想修改这些实体，只能单独把每个引用实体设置为修改状态。</p>
<h2>乐观并发模式</h2>
<p>在尝试保存使用外键关联的实体期间，如果检测到乐观并发异常，SaveChanges 将引发 DbUpdateConcurrencyException。DbUpdateConcurrencyException的 Entries 方法为无法更新的实体返回 DbEntityEntry 实例。</p>
<h2>使用DbContext执行原始SQL</h2>
<p>使用SqlQuery方法执行SQL查询</p>
<p><span style="color:blue">using</span>(<span style="color:blue">var</span> context =
<span style="color:blue">new</span><span style="color:#2B91AF">BloggingContext</span>())</p>
<p>{</p>
<p>&nbsp; <span style="color:blue">var</span> blogs =context.Blogs.SqlQuery(<span style="color:#A31515">&quot;SELECT * FROMdbo.Blogs&quot;</span>).ToList();</p>
<p>}</p>
<p>执行存储过程查询</p>
<p><span style="color:blue">using</span>(<span style="color:blue">var</span> context =
<span style="color:blue">new</span><span style="color:#2B91AF">BloggingContext</span>())</p>
<p>{</p>
<p>&nbsp; <span style="color:blue">var</span> blogs =context.Blogs.SqlQuery(<span style="color:#A31515">&quot;dbo.GetBlogs&quot;</span>).ToList();</p>
<p>}</p>
<p>&nbsp;</p>
<p>为存储过程传递参数</p>
<p><span style="color:blue">using</span>(<span style="color:blue">var</span> context =
<span style="color:blue">new</span><span style="color:#2B91AF">BloggingContext</span>())</p>
<p>{</p>
<p>&nbsp; <span style="color:blue">var</span> blogId =1;</p>
<p>&nbsp;</p>
<p>&nbsp; <span style="color:blue">var</span> blogs =context.Blogs.SqlQuery(<span style="color:#A31515">&quot;dbo.GetBlogById@p0&quot;</span>, blogId).Single();</p>
<p>}</p>
<p>查询非实体类型</p>
<p><span style="color:blue">using</span>(<span style="color:blue">var</span> context =
<span style="color:blue">new</span><span style="color:#2B91AF">BloggingContext</span>())</p>
<p>{</p>
<p>&nbsp; <span style="color:blue">var</span> blogNames= context.Database.SqlQuery&lt;<span style="color:blue">string</span>&gt;(</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#A31515">&quot;SELECTName FROM dbo.Blogs&quot;</span>).ToList();</p>
<p>}</p>
<p>返回是的对象将不会被跟踪，即使返回类型是实体类型。</p>
<p>执行SQL命令</p>
<p><span style="color:blue">using</span>(<span style="color:blue">var</span> context =
<span style="color:blue">new</span><span style="color:#2B91AF">BloggingContext</span>())</p>
<p>{</p>
<p>&nbsp; context.Database.SqlCommand(</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#A31515">&quot;UPDATEdbo.Blogs SET Name = 'Another Name' WHERE BlogId = 1&quot;</span>);</p>
<p>}</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
   
</div>




<!-- Baidu Button BEGIN -->




<div class="bdsharebuttonbox tracking-ad" style="float: right;" data-mod="popu_172">
<a href="#" class="bds_more" data-cmd="more" style="background-position:0 0 !important; background-image: url(http://bdimg.share.baidu.com/static/api/img/share/icons_0_16.png?v=d754dcc0.png) !important"></a>
<a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"  style="background-position:0 -52px !important"></a>
<a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"style="background-position:0 -104px !important"></a>
<a href="#" class="bds_tqq" data-cmd="tqq" title="分享到腾讯微博"style="background-position:0 -260px !important"></a>
<a href="#" class="bds_renren" data-cmd="renren" title="分享到人人网"style="background-position:0 -208px !important"></a>
<a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"style="background-position:0 -1612px !important" ></a>
</div>
<script>window._bd_share_config = { "common": { "bdSnsKey": {}, "bdText": "", "bdMini": "1", "bdMiniList": false, "bdPic": "", "bdStyle": "0", "bdSize": "16" }, "share": {} }; with (document) 0[(getElementsByTagName('head')[0] || body).appendChild(createElement('script')).src = 'http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=' + ~(-new Date() / 36e5)];</script>
<!-- Baidu Button END -->

   <link rel="stylesheet" href="http://static.blog.csdn.net/css/blog_detail.css" />

    
<!--172.16.140.12-->

<!-- Baidu Button BEGIN -->
<script type="text/javascript" id="bdshare_js" data="type=tools&amp;uid=1536434" ></script>
<script type="text/javascript" id="bdshell_js"></script>
<script type="text/javascript">
    document.getElementById("bdshell_js").src = "http://bdimg.share.baidu.com/static/js/shell_v2.js?cdnversion=" + Math.ceil(new Date()/3600000)
</script>
<!-- Baidu Button END -->

 

        <div id="digg" ArticleId="14004345">
            <dl id="btnDigg" class="digg digg_disable">
               
                 <dt>顶</dt>
                <dd>1</dd>
            </dl>
            <dl id="btnBury" class="digg digg_disable">
              
                  <dt>踩</dt>
                <dd>0</dd>
            </dl>
        </div>

   <ul class="article_next_prev">
                <li class="prev_article"><span  onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_shangyipian']);location.href='/gentle_wolf/article/details/9135333';">上一篇</span><a href="/gentle_wolf/article/details/9135333" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_shangyipian'])">理解和使用WPF 验证机制</a></li>
                <li class="next_article"><span onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_xiayipian']);location.href='/gentle_wolf/article/details/16338383';">下一篇</span><a href="/gentle_wolf/article/details/16338383" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_xiayipian'])">详解HostNameComparisonMode属性</a></li>
    </ul>

    <div style="clear:both; height:10px;"></div>


        <div class="similar_article"  style="display:none">
                <h4>我的同类文章</h4>
                <div class="similar_c"style="margin:20px 0px 0px 0px">
                    <div class="similar_c_t">
                                <label class="similar_cur">
                                    <span  style="cursor:pointer"  onclick="GetCategoryArticles('1358589','gentle_wolf','foot','14004345');">EF<em>（1）</em></span>
                                </label>
                    </div>
                   
                    <div class="similar_wrap tracking-ad" data-mod="popu_141"  style="max-height:195px;">
                        <a href="http://blog.csdn.net" style="display:none">http://blog.csdn.net</a>
                        <ul class="similar_list fl">                          
                        </ul>

                        <ul class="similar_list fr">                           
                        </ul>
                    </div>
                </div>
            </div>    
    <script  type="text/javascript">
        $(function () {
            GetCategoryArticles('1358589', 'gentle_wolf','foot','14004345');
        });
    </script>
      
</div>
<div id="suggest"></div>
         <script  language="javascript" type='text/javascript'>     
             $(function(){
                 $.get("/gentle_wolf/svc/GetSuggestContent/14004345",function(data){
                     $("#suggest").html(data);
                 });     
             });             
         </script>  


<style>
.blog-ass-articl dd {
color: #369;
width: 99%; /*修改行*/
float: left;
overflow: hidden;
font: normal normal 12px/23px "SimSun";
height: 23px;
margin: 0;
padding: 0 0 0 10px;
margin-right: 30px;
background: url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px;
}
</style>

<dl class="blog-ass-articl" id="res-relatived" > 
     <dt><span>猜你在找</span></dt>    


   


    <div id="adCollege" style="width: 42%;float: left;"> 
        <script src="http://csdnimg.cn/jobreco/job_reco.js" type="text/javascript"></script> 
        <script type="text/javascript">
            csdn.position.showEdu({
                sourceType: "blog",
                searchType: "detail",
                searchKey: "14004345",
                username: "",
                recordcount: "5",
                containerId: "adCollege" //容器DIV的id。 
            });
        </script> 
    </div>  

    
     <div id="res"  data-mod="popu_36"  class="tracking-ad" style="width: 42%;float: left;margin-right: 30px;"></div>
   
</dl>



<script type="text/javascript">
    $(function () {
        setTimeout(function () {
            var searchtitletags = 'Entity Framework 5.0 Code First全面学习' + ',' + $("#tags").html();
            searchService({
                index: 'blog',
                query: searchtitletags,
                from: 5,
                size: 5,
                appendTo: '#res',
                url: 'recommend',
                his: 2,
                client: "blog_cf_enhance",
                tmpl: '<dd style="background:url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px;"><a href="#{ url }" title="#{ title }" strategy="#{ strategy }">#{ title }</a></dd>'
            });
        }, 500);
    });    

 </script>   

    <div id="ad_cen">        
<!--AdForward Begin:-->
<script type="text/javascript" src="http://csdnim.qtmojo.com/main/s?user=csdn|blog|banner2&db=csdnim&border=0&local=yes&js=ie" charset="gbk"></script>
<!--AdForward End-->    </div>  

<div class="comment_class">
    <div id="comment_title" class="panel_head">
        <span class="see_comment">查看评论</span><a name="comments"></a></div>
    <div id="comment_list">
    </div>
    <div id="comment_bar">
    </div>
    <div id="comment_form">
    </div>
    <div class="announce">
        * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场<a name="reply"></a><a name="quote"></a></div>
</div>

<script type="text/javascript">
    var fileName = '14004345';
    var commentscount = 15;
    var islock = false
</script>
<script type="text/javascript" src="http://static.blog.csdn.net/scripts/comment.js"></script>
    <div id="ad_bot">
    </div>
<div id="report_dialog">
</div>

<div id="d-top"  style="bottom:60px;">
        <a id="quick-reply" class="btn btn-top q-reply" title="快速回复" style="display:none;">
            <img src="http://static.blog.csdn.net/images/blog-icon-reply.png" alt="快速回复">
        </a>    

    <a id="d-top-a" class="btn btn-top backtop"  style="display: none;" title="返回顶部" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_huidaodingbu'])" style="">         
         <img src="http://static.blog.csdn.net/images/top.png" alt="TOP">
    </a>
</div>
<script type="text/javascript">
    $(function ()
    {
        $("#ad_frm_0").height("90px");
        
        setTimeout(function(){
            $("#ad_frm_2").height("200px");
        },1000);    
    });
  
</script>
<style type="text/css">
    .tag_list
    {
        background: none repeat scroll 0 0 #FFFFFF;
        border: 1px solid #D7CBC1;
        color: #000000;
        font-size: 12px;
        line-height: 20px;
        list-style: none outside none;
        margin: 10px 2% 0 1%;
        padding: 1px;
    }
    .tag_list h5
    {
        background: none repeat scroll 0 0 #E0DBD3;
        color: #47381C;
        font-size: 12px;
        height: 24px;
        line-height: 24px;
        padding: 0 5px;
        margin: 0;
    }
    .tag_list h5 a
    {
        color: #47381C;
    }
    .classify
    {
        margin: 10px 0;
        padding: 4px 12px 8px;
    }
    .classify a
    {
        margin-right: 20px;
        white-space: nowrap;
    }
</style>


<div class="tag_list" style="display:none"></div>
  <script  language="javascript" type='text/javascript'>     
      $(function(){
              setTimeout(function(){
                  $.get("/gentle_wolf/svc/GetTagContent",function(data){
                      $(".tag_list").html(data).show();
                  });     
              });
          },500);                       
 </script> 


<div id="pop_win" style="display:none ;position: absolute; z-index: 10000; border: 1px solid rgb(220, 220, 220); top: 222.5px; left: 630px; opacity: 1; background: none 0px 0px repeat scroll rgb(255, 255, 255);">
    
</div>
<div id="popup_mask"></div>
<style>
    #popup_mask
    {
        position: absolute;
        width: 100%;
        height: 100%;
        background: #000;
        z-index: 9999;
        left: 0px;
        top: 0px;
        opacity: 0.3;
        filter: alpha(opacity=30);
        display: none;
    }

</style>




<script type="text/javascript">
    $(function(){
        setTimeout(function(){
            $(".comment_body:contains('回复')").each(function(index,item){
                var u=$(this).text().split('：')[0].toString().replace("回复","")
                var thisComment=$(this);
                if(u)
                {
                    $.getJSON("https://passport.csdn.net/get/nick?callback=?", {users: u}, function(a) {
                        if(a!=null&&a.data!=null&&a.data.length>0)
                        {
                            nick=a.data[0].n; 
                            if(u!=nick)
                            {
                                thisComment.text(thisComment.text().replace(u,nick));  
                            }
                        }       
                    });  
                }
            });
        },200);  
        
        setTimeout(function(){
            $("a img[src='http://js.tongji.linezing.com/stats.gif']").parent().css({"position":"absolute","left":"50%"});
        },300);
    });

    function loginbox(){
        var $logpop=$("#pop_win");
        $logpop.html('<iframe src="https://passport.csdn.net/account/loginbox?service=http://static.blog.csdn.net/callback.htm" frameborder="0" height="600" width="400" scrolling="no"></iframe>');

        $('#popup_mask').css({
            opacity: 0.5,
            width: $( document ).width() + 'px',
            height:  $( document ).height() + 'px'
        });
        $('#popup_mask').css("display","block");
 
        $logpop.css( {
            top: ($( window ).height() - $logpop.height())/ 2  + $( window 
       ).scrollTop() + 'px',
            left:($( window ).width() - $logpop.width())/ 2
        } );
 
        setTimeout( function () {
            $logpop.show();
            $logpop.css( {
                opacity: 1
            } );
        }, 200 );
 
        $('#popup_mask').unbind("click");
        $('#popup_mask').bind("click", function(){
            $('#popup_mask').hide();
            var $clopop = $("#pop_win");
            $("#common_ask_div_sc").css("display","none");
            $clopop.css( {
                opacity: 0
            } );
            setTimeout( function () {
                $clopop.hide();
            }, 350 );
            return false;
        });
    }    

</script>
                        <div class="clear">
                        </div>
                    </div>                   
                
            </div>
                   
           <div id="side">
    <div class="side">
<div id="panel_Profile" class="panel">
<ul class="panel_head"><span>个人资料</span></ul>
<ul class="panel_body profile">
<div id="blog_userface">
    <a href="http://my.csdn.net/gentle_wolf" target="_blank">
    <img src="http://avatar.csdn.net/1/8/2/1_gentle_wolf.jpg" title="访问我的空间" style="max-width:90%"/>
    </a>
    <br />
    <span><a href="http://my.csdn.net/gentle_wolf" class="user_name" target="_blank">gentle_wolf</a></span>
</div>
<div class="interact">

    <a href="javascript:void(0);" class="attent" id="span_add_follow" title="[加关注]"></a>

 <a href="javascript:void(0);" class="letter"  title="[发私信]" onclick="window.open('http://msg.csdn.net/letters/model?receiver=gentle_wolf','_blank','height=350,width=700');_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_sixin'])"></a>  
</div>
<div id="blog_medal">
                <div id="bms_box">
               </div>
</div>
<ul id="blog_rank">
    <li>访问：<span>180262次</span></li>
    <li>积分：<span>2408</span> </li>    
    <li >等级： <span style="position:relative;display:inline-block;z-index:1" >
            <img src="http://c.csdnimg.cn/jifen/images/xunzhang/jianzhang/blog5.png" alt="" style="vertical-align: middle;" id="leveImg">
            <div id="smallTittle" style=" position: absolute;  left: -24px;  top: 25px;  text-align: center;  width: 101px;  height: 32px;  background-color: #fff;  line-height: 32px;  border: 2px #DDDDDD solid;  box-shadow: 0px 2px 2px rgba (0,0,0,0.1);  display: none;   z-index: 999;">
            <div style="left: 42%;  top: -8px;  position: absolute;  width: 0;  height: 0;  border-left: 10px solid transparent;  border-right: 10px solid transparent;  border-bottom: 8px solid #EAEAEA;"></div>
            积分：2408 </div>
        </span>  </li>
    <li>排名：<span>第9170名</span></li>
</ul>
<ul id="blog_statistics">
    <li>原创：<span>43篇</span></li>
    <li>转载：<span>1篇</span></li>
    <li>译文：<span>23篇</span></li>
    <li>评论：<span>121条</span></li>
</ul>
</ul>
</div>


<div class="panel" id="panel_Search">
    <ul class="panel_head"><span>文章搜索</span></ul>
    <ul class="panel_body">
        <form id="frmSearch" action="http://so.csdn.net/search" class="form_search" target="_blank">
        <span><input id="inputSearch" type="text" class="blogsearch" title="请输入关键字" /></span>
        <input id="btnSubmit" type="button" value="搜索" title="search in blog" />
        <input type="hidden" name="q" id="inputQ" />
        <input type="hidden" name="t" value="blog" />
        <a id="btnSearchBlog" target="_blank"></a>
        </form>
    </ul>
</div>

<script type="text/javascript">
    $(function () {
        $("#btnSubmit").click(function () {           
            search();
        });

        $("#frmSearch").submit(function () {
            search();
            return false;
        });

        function search()
        {
            var url = "http://so.csdn.net/so/search/s.do?q=" + encodeURIComponent($("#inputSearch").val()) + "&u=" + username + "&t=blog";
            window.location.href = url;
        }   
    });
</script><div id="panel_Category" class="panel">
<ul class="panel_head"><span>文章分类</span></ul>
<ul class="panel_body">    
                 <li>
                    <a href="/gentle_wolf/article/category/441674" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">ASP.NET编程</a><span>(6)</span>
                </li>
                 <li>
                    <a href="/gentle_wolf/article/category/387763" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">LINQ 里程</a><span>(12)</span>
                </li>
                 <li>
                    <a href="/gentle_wolf/article/category/467427" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">Microsoft Enterprise Library</a><span>(4)</span>
                </li>
                 <li>
                    <a href="/gentle_wolf/article/category/511163" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">Silverlight</a><span>(1)</span>
                </li>
                 <li>
                    <a href="/gentle_wolf/article/category/490992" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">WPF</a><span>(20)</span>
                </li>
                 <li>
                    <a href="/gentle_wolf/article/category/477774" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">程序设计</a><span>(13)</span>
                </li>
                 <li>
                    <a href="/gentle_wolf/article/category/850445" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">Learning English</a><span>(16)</span>
                </li>
                 <li>
                    <a href="/gentle_wolf/article/category/935954" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">WCF</a><span>(4)</span>
                </li>
                 <li>
                    <a href="/gentle_wolf/article/category/1358589" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">EF</a><span>(2)</span>
                </li>
</ul>
</div><div id="panel_Archive" class="panel">
<ul class="panel_head"><span>文章存档</span></ul>
<ul class="panel_body">
<div id="archive_list">
<!--归档统计-->
<li><a href="/gentle_wolf/article/month/2016/01">2016年01月</a><span>(1)</span></li><li><a href="/gentle_wolf/article/month/2014/10">2014年10月</a><span>(1)</span></li><li><a href="/gentle_wolf/article/month/2014/06">2014年06月</a><span>(2)</span></li><li><a href="/gentle_wolf/article/month/2014/04">2014年04月</a><span>(3)</span></li><li><a href="/gentle_wolf/article/month/2014/03">2014年03月</a><span>(1)</span></li><li><a href="/gentle_wolf/article/month/2014/02">2014年02月</a><span>(10)</span></li><li><a href="/gentle_wolf/article/month/2014/01">2014年01月</a><span>(1)</span></li><li><a href="/gentle_wolf/article/month/2013/12">2013年12月</a><span>(2)</span></li><li><a href="/gentle_wolf/article/month/2013/11">2013年11月</a><span>(4)</span></li><li><a href="/gentle_wolf/article/month/2013/06">2013年06月</a><span>(1)</span></li><li><a href="/gentle_wolf/article/month/2013/04">2013年04月</a><span>(2)</span></li><li><a href="/gentle_wolf/article/month/2013/03">2013年03月</a><span>(3)</span></li><li><a href="/gentle_wolf/article/month/2012/12">2012年12月</a><span>(1)</span></li><li><a href="/gentle_wolf/article/month/2012/09">2012年09月</a><span>(1)</span></li><li><a href="/gentle_wolf/article/month/2012/02">2012年02月</a><span>(1)</span></li><li><a href="/gentle_wolf/article/month/2011/11">2011年11月</a><span>(1)</span></li><li><a href="/gentle_wolf/article/month/2011/08">2011年08月</a><span>(1)</span></li><li><a href="/gentle_wolf/article/month/2011/07">2011年07月</a><span>(11)</span></li><li><a href="/gentle_wolf/article/month/2011/05">2011年05月</a><span>(4)</span></li><li><a href="/gentle_wolf/article/month/2010/12">2010年12月</a><span>(3)</span></li><li><a href="/gentle_wolf/article/month/2010/11">2010年11月</a><span>(1)</span></li><li><a href="/gentle_wolf/article/month/2010/09">2010年09月</a><span>(1)</span></li><li><a href="/gentle_wolf/article/month/2010/04">2010年04月</a><span>(1)</span></li><li><a href="/gentle_wolf/article/month/2009/02">2009年02月</a><span>(1)</span></li><li><a href="/gentle_wolf/article/month/2008/11">2008年11月</a><span>(5)</span></li><li><a href="/gentle_wolf/article/month/2008/10">2008年10月</a><span>(1)</span></li><li><a href="/gentle_wolf/article/month/2008/09">2008年09月</a><span>(2)</span></li><li><a href="/gentle_wolf/article/month/2008/08">2008年08月</a><span>(1)</span></li><li><a href="/gentle_wolf/article/month/2008/07">2008年07月</a><span>(8)</span></li><li><a href="/gentle_wolf/article/month/2008/06">2008年06月</a><span>(4)</span></li>
</div>
</ul>
</div>
<div id="hotarticls" class="panel">
<ul class="panel_head">
    <span>       
阅读排行    </span>
</ul>

<ul class="panel_body itemlist">
<li>
<a href="/gentle_wolf/article/details/14004345" title="Entity Framework 5.0 Code First全面学习">Entity Framework 5.0 Code First全面学习</a><span>(44154)</span>
</li>
<li>
<a href="/gentle_wolf/article/details/5908340" title="自定义WPF 窗口样式">自定义WPF 窗口样式</a><span>(11506)</span>
</li>
<li>
<a href="/gentle_wolf/article/details/2603018" title="LINQ to Object 全攻略">LINQ to Object 全攻略</a><span>(10697)</span>
</li>
<li>
<a href="/gentle_wolf/article/details/2724208" title="使用XML LINQ查询和转换XML">使用XML LINQ查询和转换XML</a><span>(6587)</span>
</li>
<li>
<a href="/gentle_wolf/article/details/2708386" title="LINQ to XML简介">LINQ to XML简介</a><span>(5262)</span>
</li>
<li>
<a href="/gentle_wolf/article/details/8644010" title="Entity Framework in Action摘要">Entity Framework in Action摘要</a><span>(4095)</span>
</li>
<li>
<a href="/gentle_wolf/article/details/2665311" title="深入LINQ to SQL">深入LINQ to SQL</a><span>(3773)</span>
</li>
<li>
<a href="/gentle_wolf/article/details/7944959" title="创建WatermarkTextBox和WatermarkPasswordBox（带水印的文本框）">创建WatermarkTextBox和WatermarkPasswordBox（带水印的文本框）</a><span>(3547)</span>
</li>
<li>
<a href="/gentle_wolf/article/details/9135333" title="理解和使用WPF 验证机制">理解和使用WPF 验证机制</a><span>(3245)</span>
</li>
<li>
<a href="/gentle_wolf/article/details/2588615" title="初识LINQ">初识LINQ</a><span>(3200)</span>
</li>
</ul>
</div>
<div id="hotarticls2" class="panel">
<ul class="panel_head"><span>评论排行</span></ul>
<ul class="panel_body itemlist">
<li>
<a href="/gentle_wolf/article/details/5908340" title="自定义WPF 窗口样式">自定义WPF 窗口样式</a><span>(43)</span>
</li>
<li>
<a href="/gentle_wolf/article/details/14004345" title="Entity Framework 5.0 Code First全面学习">Entity Framework 5.0 Code First全面学习</a><span>(15)</span>
</li>
<li>
<a href="/gentle_wolf/article/details/2588615" title="初识LINQ">初识LINQ</a><span>(10)</span>
</li>
<li>
<a href="/gentle_wolf/article/details/2603018" title="LINQ to Object 全攻略">LINQ to Object 全攻略</a><span>(9)</span>
</li>
<li>
<a href="/gentle_wolf/article/details/6067757" title="四叉树C#实现">四叉树C#实现</a><span>(8)</span>
</li>
<li>
<a href="/gentle_wolf/article/details/2769071" title="在ASP.NET中使用自定义配置">在ASP.NET中使用自定义配置</a><span>(6)</span>
</li>
<li>
<a href="/gentle_wolf/article/details/6057812" title="为ListView添加矩形选择功能">为ListView添加矩形选择功能</a><span>(6)</span>
</li>
<li>
<a href="/gentle_wolf/article/details/7944959" title="创建WatermarkTextBox和WatermarkPasswordBox（带水印的文本框）">创建WatermarkTextBox和WatermarkPasswordBox（带水印的文本框）</a><span>(5)</span>
</li>
<li>
<a href="/gentle_wolf/article/details/3866031" title="silverlight cross domain 访问策略配置文件">silverlight cross domain 访问策略配置文件</a><span>(3)</span>
</li>
<li>
<a href="/gentle_wolf/article/details/3394229" title="最优化实现ASP.NET页面的返回和刷新机制">最优化实现ASP.NET页面的返回和刷新机制</a><span>(3)</span>
</li>
</ul>
</div>
<div id="homepageArticles" class="panel tracking-ad" data-mod="popu_4">
<ul class="panel_head"><span>推荐文章</span></ul>
<ul class="panel_body" id="ad_commend">
<ul>
<li><a href="http://blog.csdn.net/wingichoy/article/details/50590051" 

target="_blank">*一个炫字都不够？？！！！手把手带你打造3D自定义view</a></li>
<li><a href="http://blog.csdn.net/Pwiling/article/details/50573650" 

target="_blank">*21行python代码实现拼写检查器</a></li>
<li><a href="http://blog.csdn.net/u011225629/article/details/50492403" 

target="_blank">*数据库性能优化之SQL语句优化</a></li>
<li><a 

href="http://blog.csdn.net/bluecloudmatrix/article/details/50525225"target="_blank">*拉开大变革序幕（下）：分布式计算框架与大数据</a></li>
<li><a href="http://blog.csdn.net/luoshengyang/article/details/50527574" 

target="_blank">*Chromium网页URL加载过程分析</a></li>
<li><a href="http://blog.csdn.net/androidlushangderen/article/details/50571584"  

target="_blank">*Hadoop中止下线操作后大量剩余复制块的解决方案</a></li>

</ul></ul>
</div>


<div id="newcomments" class="panel">
<ul class="panel_head"><span>最新评论</span></ul>
<ul class="panel_body itemlist">
    <li>
   
         <a href="/gentle_wolf/article/details/6067757#comments">四叉树C#实现</a>
    <p style="margin:0px;"><a href="/FrankieLJY" class="user_name">FrankieLJY</a>:
楼主要是能写些注解就好了，看起来好吃力
    </p>
    </li>
    <li>
   
         <a href="/gentle_wolf/article/details/14004345#comments">Entity Framework 5.0 Code First全面学习</a>
    <p style="margin:0px;"><a href="/u010108195" class="user_name">u010108195</a>:
建议这篇博客可以分序列写，对于我们读者给容易阅读
    </p>
    </li>
    <li>
   
         <a href="/gentle_wolf/article/details/14004345#comments">Entity Framework 5.0 Code First全面学习</a>
    <p style="margin:0px;"><a href="/u010028869" class="user_name">u010028869</a>:
很全面，但是感觉不清晰。
    </p>
    </li>
    <li>
   
         <a href="/gentle_wolf/article/details/6456678#comments">再谈透明代理</a>
    <p style="margin:0px;"><a href="/wangqingbo0829" class="user_name">wangqingbo0829</a>:
特学习！
    </p>
    </li>
    <li>
   
         <a href="/gentle_wolf/article/details/5908340#comments">自定义WPF 窗口样式</a>
    <p style="margin:0px;"><a href="/u014337101" class="user_name">u014337101</a>:
看 了一下，感觉还是有点缺陷所在，敢问楼主初始化给最大化的话，界面还会覆盖下面的任务栏，怎么来解决这...
    </p>
    </li>
    <li>
   
         <a href="/gentle_wolf/article/details/5908340#comments">自定义WPF 窗口样式</a>
    <p style="margin:0px;"><a href="/u014337101" class="user_name">u014337101</a>:
@u012074299:看了下，不过还是有点缺陷，不知楼主可以答复下，如果初始化给最大化，他的界面就...
    </p>
    </li>
    <li>
   
         <a href="/gentle_wolf/article/details/5908340#comments">Entity Framework 5.0 Code First全面学习</a>
    <p style="margin:0px;"><a href="/u010514988" class="user_name">u010514988</a>:
@ananmxw:为何不把数据量很大的数据表改名，创建一个新的数据表来放数据？
    </p>
    </li>
    <li>
   
         <a href="/gentle_wolf/article/details/7944959#comments">创建WatermarkTextBox和WatermarkPasswordBox（带水印的文本框）</a>
    <p style="margin:0px;"><a href="/yangyanghaoran" class="user_name">yangyanghaoran</a>:
我把 Microsoft_Windows_Themes:ListBoxChrome    换成bor...
    </p>
    </li>
    <li>
   
         <a href="/gentle_wolf/article/details/7944959#comments">Entity Framework 5.0 Code First全面学习</a>
    <p style="margin:0px;"><a href="/lechengbo" class="user_name">lechengbo</a>:
不错的文章，要能写的更通俗易懂就更好了
    </p>
    </li>
    <li>
   
         <a href="/gentle_wolf/article/details/7944959#comments">Entity Framework 5.0 Code First全面学习</a>
    <p style="margin:0px;"><a href="/u013262789" class="user_name">u013262789</a>:
不给力啊。怎么文章都是讲用ef的，网上到处是这种文章。你讲code first也没讲讲怎么配置con...
    </p>
    </li>
</ul>
</div>
    </div>
    <div class="clear">
    </div>
 </div>   
            <div class="clear">
            </div>
        </div>
        

<script type="text/javascript" src="http://c.csdnimg.cn/rabbit/cnick/cnick.js"></script>
<script type="text/javascript" src="http://static.blog.csdn.net/scripts/newblog.min.js"></script>


<script type="text/javascript" src="http://medal.blog.csdn.net/showblogmedal.ashx?blogid=106236"></script>
<script type="text/javascript" src="http://static.blog.csdn.net/scripts/JavaScript1.js"></script>

    <script type="text/javascript" src="http://passport.csdn.net/content/loginbox/login.js"></script>
<script type="text/javascript">document.write("<img src=http://counter.csdn.net/pv.aspx?id=24 border=0 width=0 height=0>");</script>
<script type="text/javascript" src="http://www.csdn.net/ui/scripts/Csdn/counter.js"></script>
<script type="text/javascript" src="http://ad.csdn.net/scripts/ad-blog.js"></script>
<script type="text/javascript">
    $(function () {
        function __get_code_toolbar(snippet_id) {
            return $("<span class='tracking-ad' data-mod='popu_167'><a href='https://code.csdn.net/snippets/"
                    + snippet_id
                    + "' target='_blank' title='在CODE上查看代码片'  style='text-indent:0;'><img src='https://code.csdn.net/assets/CODE_ico.png' width=12 height=12 alt='在CODE上查看代码片' style='position:relative;top:1px;left:2px;'/></a></span>"
                    + "<span class='tracking-ad' data-mod='popu_170'><a href='https://code.csdn.net/snippets/"
                    + snippet_id
                    + "/fork' target='_blank' title='派生到我的代码片' style='text-indent:0;'><img src='https://code.csdn.net/assets/ico_fork.svg' width=12 height=12 alt='派生到我的代码片' style='position:relative;top:2px;left:2px;'/></a></span>");
        }
        
        $("[code_snippet_id]").each(function () {
            __s_id = $(this).attr("code_snippet_id");
            if (__s_id != null && __s_id != "" && __s_id != 0 && parseInt(__s_id) > 70020) {
                __code_tool = __get_code_toolbar(__s_id);
                $(this).prev().find(".tools").append(__code_tool);
            }
        });

        $(".bar").show();
    });
</script>




    </div>
      <!--new top-->
    
    <script id="csdn-toolbar-id" btnId="header_notice_num" wrapId="note1" count="5" subCount="5" type="text/javascript" src="http://c.csdnimg.cn/public/common/toolbar/js/toolbar.js"></script>     <!--new top-->
   
    <link href="http://c.csdnimg.cn/comm_ask/css/ask_float_block.css" type="text/css" rel="stylesheet" />
    <script language='JavaScript' type='text/javascript' src='http://c.csdnimg.cn/comm_ask/js/libs/wmd.js'></script>
    <script language='JavaScript' type='text/javascript' src='http://c.csdnimg.cn/comm_ask/js/libs/showdown.js'></script>
    <script language='JavaScript' type='text/javascript' src='http://c.csdnimg.cn/comm_ask/js/libs/prettify.js'></script>
    <script language='JavaScript' type='text/javascript' src='http://c.csdnimg.cn/comm_ask/js/apps/ask_float_block.js'></script>
   
</body>
</html>   
 